{"original_position": 260, "diff_hunk": "@@ -0,0 +1,296 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n+\n+/**\n+ * Preference Experiments temporarily change a preference to one of several test\n+ * values for the duration of the experiment. Telemetry packets are annotated to\n+ * show what experiments are active, and we use this data to measure the\n+ * effectiveness of the preference change.\n+ *\n+ * Info on active and past experiments is stored in a JSON file in the profile\n+ * folder.\n+ *\n+ * Active preference experiments are stopped if they aren't active on the recipe\n+ * server. They also expire if Firefox isn't able to contact the recipe server\n+ * after a period of time, as well as if the user modifies the preference during\n+ * an active experiment.\n+ */\n+\n+/**\n+ * Experiments store info about an active or expired preference experiment.\n+ * They are single-depth objects to simplify cloning.\n+ * @typedef {Object} Experiment\n+ * @property {string} name\n+ *   Unique name of the experiment\n+ * @property {string} branch\n+ *   Experiment branch that the user was matched to\n+ * @property {boolean} expired\n+ *   If false, the experiment is active.\n+ * @property {string} lastSeen\n+ *   ISO-formatted date string of when the experiment was last seen from the\n+ *   recipe server.\n+ * @property {string} preferenceName\n+ *   Name of the preference affected by this experiment.\n+ * @property {string|integer|boolean} preferenceValue\n+ *   Value to change the preference to during the experiment.\n+ * @property {string|integer|boolean|undefined} previousPreferenceValue\n+ *   Value of the preference prior to the experiment, or undefined if it was\n+ *   unset.\n+ */\n+\n+\"use strict\";\n+\n+const {utils: Cu} = Components;\n+Cu.import(\"resource://gre/modules/XPCOMUtils.jsm\");\n+\n+XPCOMUtils.defineLazyModuleGetter(this, \"CleanupManager\", \"resource://shield-recipe-client/lib/CleanupManager.jsm\");\n+XPCOMUtils.defineLazyModuleGetter(this, \"JSONFile\", \"resource://gre/modules/JSONFile.jsm\");\n+XPCOMUtils.defineLazyModuleGetter(this, \"OS\", \"resource://gre/modules/osfile.jsm\");\n+XPCOMUtils.defineLazyModuleGetter(this, \"LogManager\", \"resource://shield-recipe-client/lib/LogManager.jsm\");\n+XPCOMUtils.defineLazyModuleGetter(this, \"Preferences\", \"resource://gre/modules/Preferences.jsm\");\n+\n+this.EXPORTED_SYMBOLS = [\"PreferenceExperiments\"];\n+\n+const EXPERIMENT_FILE = \"shield-preference-experiments.json\";\n+\n+/**\n+ * Asynchronously load the JSON file that stores experiment status in the profile.\n+ */\n+let storePromise;\n+function loadStorage() {\n+  if (storePromise === undefined) {\n+    const path = OS.Path.join(OS.Constants.Path.profileDir, EXPERIMENT_FILE);\n+    const storage = new JSONFile({path});\n+    storePromise = storage.load().then(() => storage);\n+  }\n+  return storePromise;\n+}\n+\n+const log = LogManager.getLogger(\"preference-experiments\");\n+\n+// List of active preference observers. Cleaned up on shutdown.\n+let experimentObservers = {};\n+CleanupManager.addCleanupHandler(() => PreferenceExperiments.stopAllObservers());\n+\n+this.PreferenceExperiments = {\n+  /**\n+   * Test wrapper that temporarily replaces the stored experiment data with fake\n+   * data for testing.\n+   */\n+  withMockExperiments(testGenerator) {\n+    return function* inner(...args) {\n+      const oldPromise = storePromise;\n+      const mockExperiments = {};\n+      storePromise = Promise.resolve({\n+        data: mockExperiments,\n+        saveSoon() { },\n+      });\n+      try {\n+        yield testGenerator(...args, mockExperiments);\n+      } finally {\n+        storePromise = oldPromise;\n+      }\n+    };\n+  },\n+\n+  /**\n+   * Clear all stored data about active and past experiments.\n+   */\n+  async clearAllExperimentStorage() {\n+    const store = await loadStorage();\n+    store.data = {};\n+    store.saveSoon();\n+  },\n+\n+  /**\n+   * Start a new preference experiment.\n+   * @param  {string} experimentName\n+   * @param  {string} branch\n+   * @param  {string} preferenceName\n+   * @param  {string|integer|boolean} preferenceValue\n+   * @rejects {Error}\n+   *   If an experiment with the given name already exists, or if an experiment\n+   *   for the given preference is active.\n+   */\n+  async start(experimentName, branch, preferenceName, preferenceValue) {\n+    log.debug(`PreferenceExperiments.start(${experimentName}, ${branch})`);\n+\n+    const store = await loadStorage();\n+    if (experimentName in store.data) {\n+      throw new Error(`A preference experiment named \"${experimentName}\" already exists.`);\n+    }\n+\n+    const activeExperiments = Object.values(store.data).filter(e => !e.expired);\n+    const hasConflictingExperiment = activeExperiments.some(\n+      e => e.preferenceName === preferenceName\n+    );\n+    if (hasConflictingExperiment) {\n+      throw new Error(\n+        `Another preference experiment for the pref \"${preferenceName}\" is currently active.`\n+      );\n+    }\n+\n+    /** @type {Experiment} */\n+    const experiment = {\n+      name: experimentName,\n+      branch,\n+      expired: false,\n+      lastSeen: new Date().toJSON(),\n+      preferenceName,\n+      preferenceValue,\n+      previousPreferenceValue: Preferences.get(preferenceName, undefined),\n+    };\n+\n+    Preferences.set(preferenceName, preferenceValue);\n+    PreferenceExperiments.startObserver(experimentName, preferenceName, preferenceValue);\n+    store.data[experimentName] = experiment;\n+    store.saveSoon();\n+  },\n+\n+  /**\n+   * Register a preference observer that stops an experiment when the user\n+   * modifies the preference.\n+   * @param {string} experimentName\n+   * @param {string} preferenceName\n+   * @param {string|integer|boolean} preferenceValue\n+   * @throws {Error}\n+   *   If an observer for the named experiment is already active.\n+   */\n+  startObserver(experimentName, preferenceName, preferenceValue) {\n+    log.debug(`PreferenceExperiments.startObserver(${experimentName})`);\n+\n+    if (experimentName in experimentObservers) {\n+      throw new Error(\n+        `An observer for the preference experiment ${experimentName} is already active.`\n+      );\n+    }\n+\n+    const observerInfo = {\n+      preferenceName,\n+      observer(newValue) {\n+        if (newValue !== preferenceValue) {\n+          PreferenceExperiments.stop(experimentName, false);\n+        }\n+      },\n+    };\n+    experimentObservers[experimentName] = observerInfo;\n+    Preferences.observe(preferenceName, observerInfo.observer);\n+  },\n+\n+  /**\n+   * Disable a preference observer for the named experiment.\n+   * @param {string} experimentName\n+   * @throws {Error}\n+   *   If there is no active observer for the named experiment.\n+   */\n+  stopObserver(experimentName) {\n+    log.debug(`PreferenceExperiments.stopObserver(${experimentName})`);\n+\n+    if (!(experimentName in experimentObservers)) {\n+      throw new Error(`No observer for the preference experiment ${experimentName} found.`);\n+    }\n+\n+    const {preferenceName, observer} = experimentObservers[experimentName];\n+    Preferences.ignore(preferenceName, observer);\n+    delete experimentObservers[experimentName];\n+  },\n+\n+  /**\n+   * Disable all currently-active preference observers for experiments.\n+   */\n+  stopAllObservers() {\n+    log.debug(\"PreferenceExperiments.stopAllObservers()\");\n+    for (const {preferenceName, observer} of Object.values(experimentObservers)) {\n+      Preferences.ignore(preferenceName, observer);\n+    }\n+    experimentObservers = {};\n+  },\n+\n+  /**\n+   * Update the timestamp storing when Normandy last sent a recipe for the named\n+   * experiment.\n+   * @param {string} experimentName\n+   * @rejects {Error}\n+   *   If there is no stored experiment with the given name.\n+   */\n+  async markLastSeen(experimentName) {\n+    log.debug(`PreferenceExperiments.markLastSeen(${experimentName})`);\n+\n+    const store = await loadStorage();\n+    if (!(experimentName in store.data)) {\n+      throw new Error(`Could not find a preference experiment named \"${experimentName}\"`);\n+    }\n+\n+    store.data[experimentName].lastSeen = new Date().toJSON();\n+    store.saveSoon();\n+  },\n+\n+  /**\n+   * Stop an active experiment, deactivate preference watchers, and optionally\n+   * reset the associated preference to its previous value.\n+   * @param {string} experimentName\n+   * @param {boolean} [resetValue=true]\n+   *   If true, reset the preference to its original value.\n+   * @rejects {Error}\n+   *   If there is no stored experiment with the given name, or if the\n+   *   experiment has already expired.\n+   */\n+  async stop(experimentName, resetValue = true) {\n+    log.debug(`PreferenceExperiments.stop(${experimentName})`);\n+\n+    const store = await loadStorage();\n+    if (!(experimentName in store.data)) {\n+      throw new Error(`Could not find a preference experiment named \"${experimentName}\"`);\n+    }\n+\n+    const experiment = store.data[experimentName];\n+    if (experiment.expired) {\n+      throw new Error(\n+        `Cannot stop preference experiment \"${experimentName}\" because it is already expired`\n+      );\n+    }\n+\n+    PreferenceExperiments.stopObserver(experimentName);\n+\n+    if (resetValue) {\n+      const {preferenceName, previousPreferenceValue} = experiment;\n+      Preferences.reset(preferenceName);\n+      if (previousPreferenceValue !== undefined) {\n+        Preferences.set(preferenceName, previousPreferenceValue);", "body_text": "Sure, but we could do:\nif (previousPreferenceValue !== undefined) {\n  Preferences.set(preferenceName, previousPreferenceValue);\n} else {\n  Preferences.reset(preferenceName);\n}", "in_reply_to_id": 107293130, "pull_request_url": "https://api.github.com/repos/mozilla/normandy/pulls/623", "url": "https://api.github.com/repos/mozilla/normandy/pulls/comments/107399246", "created_at": "2017-03-22T12:21:32Z", "author_association": "CONTRIBUTOR", "body": "Sure, but we could do:\r\n\r\n```js\r\nif (previousPreferenceValue !== undefined) {\r\n  Preferences.set(preferenceName, previousPreferenceValue);\r\n} else {\r\n  Preferences.reset(preferenceName);\r\n}\r\n```", "updated_at": "2017-03-25T04:25:33Z", "html_url": "https://github.com/mozilla/normandy/pull/623#discussion_r107399246", "pull_request_review_id": 28366886, "_links": {"self": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/comments/107399246"}, "html": {"href": "https://github.com/mozilla/normandy/pull/623#discussion_r107399246"}, "pull_request": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/623"}}, "commit_id": "6bf1456bdc7a171d0c91c246b0cb9906dd2e320e", "user": {"following_url": "https://api.github.com/users/gijsk/following{/other_user}", "events_url": "https://api.github.com/users/gijsk/events{/privacy}", "organizations_url": "https://api.github.com/users/gijsk/orgs", "url": "https://api.github.com/users/gijsk", "gists_url": "https://api.github.com/users/gijsk/gists{/gist_id}", "html_url": "https://github.com/gijsk", "subscriptions_url": "https://api.github.com/users/gijsk/subscriptions", "avatar_url": "https://avatars3.githubusercontent.com/u/375983?v=4", "repos_url": "https://api.github.com/users/gijsk/repos", "received_events_url": "https://api.github.com/users/gijsk/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/gijsk/starred{/owner}{/repo}", "site_admin": false, "login": "gijsk", "type": "User", "id": 375983, "followers_url": "https://api.github.com/users/gijsk/followers"}, "position": null, "path": "recipe-client-addon/lib/PreferenceExperiments.jsm", "body_html": "<p>Sure, but we could do:</p>\n<div class=\"highlight highlight-source-js\"><pre><span class=\"pl-k\">if</span> (previousPreferenceValue <span class=\"pl-k\">!==</span> <span class=\"pl-c1\">undefined</span>) {\n  <span class=\"pl-smi\">Preferences</span>.<span class=\"pl-c1\">set</span>(preferenceName, previousPreferenceValue);\n} <span class=\"pl-k\">else</span> {\n  <span class=\"pl-smi\">Preferences</span>.<span class=\"pl-c1\">reset</span>(preferenceName);\n}</pre></div>", "original_commit_id": "f4732714cbf1fbdf2bcd59fc95e1894330d44425", "id": 107399246}