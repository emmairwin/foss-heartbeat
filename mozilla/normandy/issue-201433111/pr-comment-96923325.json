{"original_position": 181, "diff_hunk": "@@ -16,35 +19,218 @@ export default class ShowHeartbeatAction extends Action {\n     // 'global' storage\n     // (constant namespace - all heartbeats can access)\n     this.heartbeatStorage = normandy.createStorage('normandy-heartbeat');\n+\n+    // context bindings\n+    this.updateLastInteraction = ::this.updateLastInteraction;\n+    this.updateLastShown = ::this.updateLastShown;\n+  }\n+\n+  /**\n+   * Returns a surveyId value. If recipe calls\n+   * to include the Telemetry UUID value,\n+   * then the UUID is attached to the surveyId\n+   * in `<surveyId>::<userId>` format.\n+   *\n+   * @return {String} Survey ID, possibly with user UUID\n+   */\n+  generateSurveyId() {\n+    const {\n+      includeTelemetryUUID,\n+      surveyId,\n+    } = this.recipe.arguments;\n+    const { userId } = this.normandy;\n+\n+    let value = surveyId;\n+\n+    // should user ID stuff be sent to telemetry?\n+    if (includeTelemetryUUID && !!userId) {\n+      // alter the survey ID to include that UUID\n+      value = `${surveyId}::${userId}`;\n+    }\n+\n+    return value;\n   }\n \n   /**\n-   * Calculates the number of milliseconds since the last heartbeat from any recipe\n-   * was shown. Returns a boolean indicating if a heartbeat has been shown recently.\n+   * Returns a boolean indicating if a heartbeat has been shown recently.\n+   *\n+   * Checks the saved `lastShown` value against the current time\n+   * and returns if the time is under HEARTBEAT_THROTTLE milliseconds.\n+   *\n+   * @async\n+   * @return {Boolean}  Has any heartbeat been shown recently?\n    */\n   async heartbeatShownRecently() {\n     const lastShown = await this.heartbeatStorage.getItem('lastShown');\n-    const timeSince = lastShown ? new Date() - lastShown : Infinity;\n+    const timeSince = !!lastShown ? // eslint-disable-line no-extra-boolean-cast\n+      new Date() - parseFloat(lastShown) : Infinity;\n \n     // Return a boolean indicating if a heartbeat\n     // has shown within the last HEARTBEAT_THROTTLE ms\n     return timeSince < HEARTBEAT_THROTTLE;\n   }\n \n   /**\n+   * Looks up the time the prompt was last displayed to the user,\n+   * and converts it to a Number (if found).\n+   *\n+   * @async\n+   * @return {number}   Timestamp of last prompt showing\n+   */\n+  async getLastShown() {\n+    const lastShown = await this.storage.getItem('lastShown');\n+    return typeof lastShown !== 'undefined' ?\n+      parseFloat(lastShown) : null;\n+  }\n+\n+  /**\n    * Checks when this survey was last shown,\n    * and returns a boolean indicating if the\n-   * user has seen this survey already or not.\n+   * user has ever seen this survey or not.\n+   *\n+   * @async\n+   * @return {Boolean}  Has the survey ever been shown?\n    */\n-  async surveyHasShown() {\n-    const lastShown = await this.storage.getItem('lastShown');\n+  async hasShownBefore() {\n+    const lastShown = await this.getLastShown();\n     // If no survey has been shown, lastShown will be falsey.\n     return !!lastShown;\n   }\n \n+  /**\n+   * Determines if this heartbeat was shown\n+   * at least x days ago.\n+   *\n+   * @param  {Number}  days Days ago to check\n+   * @return {boolean}      Has prompt been shown by that date?\n+   */\n+  async shownAtleastDaysAgo(days) {\n+    const hasShown = await this.hasShownBefore();\n+\n+    if (!hasShown) {\n+      return false;\n+    }\n+\n+    // get timestamp of last shown\n+    const timeLastShown = await this.getLastShown();\n+\n+    // get the difference between now and then\n+    const timeElapsed = Date.now() - timeLastShown;\n+\n+    // time limit is the number of days passed in\n+    // converted into milliseconds\n+    const timeLimit = ONE_DAY * days;\n+\n+    // if the diff is smaller than the limit,\n+    // that means that the last time the user saw the prompt\n+    // was less than the `days` passed in\n+    return timeElapsed < timeLimit;\n+  }\n+\n+  /**\n+   * Simple function to read the lastInteraction\n+   * timestamp (if any) from local storage.\n+   * @return {number}   Timestamp of last prompt interaction (if any)\n+   */\n+  async getLastInteraction() {\n+    const lastInteraction = await this.storage.getItem('lastInteraction');\n+\n+    return typeof lastInteraction !== 'undefined' ?\n+      parseFloat(lastInteraction) : null;\n+  }\n+\n+  /**\n+   * Gets the timestamp of the last prompt interaction,\n+   * and returns the time (in ms) since then.\n+   *\n+   * @async\n+   * @return {number}\n+   */\n+  async sinceLastInteraction() {\n+    const lastInteraction = await this.getLastInteraction();\n+\n+    return typeof lastInteraction !== 'undefined' ?\n+      Date.now() - lastInteraction : null;\n+  }\n+\n+  /**\n+   * Checks when the survey prompt last had\n+   * interaction from the user (if ever),\n+   * and returns a boolean indicating if the\n+   * user has ever had interaction\n+   *\n+   * @async\n+   * @return {Boolean}  Has the survey ever had interaction?\n+   */\n+  async hasHadInteraction() {\n+    const lastInteraction = await this.getLastInteraction();\n+    return !!lastInteraction;\n+  }\n+\n+  /**\n+   * Checks the repeat argument for this recipe,\n+   * then determines if the recipe can be qualified as 'ran'.\n+   * This ultimately decides if the prompt is shown at all\n+   * to the end user.\n+   *\n+   * @return {boolean}        Has the heartbeat been shown?\n+   */\n+  async heartbeatHasRan() {", "body_text": "This name isn't accurate, as it is talking about if the heartbeat should run. For example, it doesn't matter if a nag heartbeat hasRan, since it should run again anyways (unless there has been interaction).", "pull_request_url": "https://api.github.com/repos/mozilla/normandy/pulls/429", "url": "https://api.github.com/repos/mozilla/normandy/pulls/comments/96923325", "created_at": "2017-01-19T18:23:05Z", "author_association": "MEMBER", "body": "This name isn't accurate, as it is talking about if the heartbeat should run. For example, it doesn't matter if a nag heartbeat `hasRan`, since it should run again anyways (unless there has been interaction).", "updated_at": "2017-01-25T17:16:54Z", "html_url": "https://github.com/mozilla/normandy/pull/429#discussion_r96923325", "pull_request_review_id": 17512272, "_links": {"self": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/comments/96923325"}, "html": {"href": "https://github.com/mozilla/normandy/pull/429#discussion_r96923325"}, "pull_request": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/429"}}, "commit_id": "d5274b2a2f7acd69f4786a61d91518dd6c82ab41", "user": {"following_url": "https://api.github.com/users/mythmon/following{/other_user}", "events_url": "https://api.github.com/users/mythmon/events{/privacy}", "organizations_url": "https://api.github.com/users/mythmon/orgs", "url": "https://api.github.com/users/mythmon", "gists_url": "https://api.github.com/users/mythmon/gists{/gist_id}", "html_url": "https://github.com/mythmon", "subscriptions_url": "https://api.github.com/users/mythmon/subscriptions", "avatar_url": "https://avatars3.githubusercontent.com/u/305049?v=4", "repos_url": "https://api.github.com/users/mythmon/repos", "received_events_url": "https://api.github.com/users/mythmon/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/mythmon/starred{/owner}{/repo}", "site_admin": false, "login": "mythmon", "type": "User", "id": 305049, "followers_url": "https://api.github.com/users/mythmon/followers"}, "position": null, "path": "recipe-server/client/actions/show-heartbeat/index.js", "body_html": "<p>This name isn't accurate, as it is talking about if the heartbeat should run. For example, it doesn't matter if a nag heartbeat <code>hasRan</code>, since it should run again anyways (unless there has been interaction).</p>", "original_commit_id": "fd8be9d878551e484d9a2439b725c9bb42c436ce", "id": 96923325}