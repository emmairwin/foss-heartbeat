{"original_position": 283, "diff_hunk": "@@ -664,140 +665,179 @@ def test_sets_no_cookies(self, api_client):\n \n \n @pytest.mark.django_db\n-def test_full_approval_flow(api_client, mocked_autograph):\n-    action = ActionFactory()\n-    user1 = UserFactory(is_superuser=True)\n-    user2 = UserFactory(is_superuser=True)\n-    api_client.force_authenticate(user1)\n-\n-    # Create a recipe\n-    res = api_client.post('/api/v1/recipe/', {\n-        'action': action.name,\n-        'arguments': {},\n-        'name': 'test recipe',\n-        'extra_filter_expression': 'counter == 0',\n-        'enabled': 'false',\n-    })\n-    assert res.status_code == 201\n-    recipe_data_0 = res.json()\n-\n-    # Request approval for it\n-    res = api_client.post('/api/v1/recipe_revision/{}/request_approval/'\n-                          .format(recipe_data_0['revision_id']))\n-    approval_data = res.json()\n-    assert res.status_code == 201\n-\n-    # The requester isn't allowed to approve a recipe\n-    res = api_client.post('/api/v1/approval_request/{}/approve/'.format(approval_data['id']),\n-                          {'comment': 'r+'})\n-    assert res.status_code == 403  # Forbidden\n-\n-    # Approve the recipe\n-    api_client.force_authenticate(user2)\n-    res = api_client.post('/api/v1/approval_request/{}/approve/'.format(approval_data['id']),\n-                          {'comment': 'r+'})\n-    assert res.status_code == 200\n-\n-    # It is now visible in the API\n-    res = api_client.get('/api/v1/recipe/{}/'.format(recipe_data_0['id']))\n-    assert res.status_code == 200\n-    recipe_data_1 = res.json()\n-\n-    # It is signed correctly\n-    res = api_client.get('/api/v1/recipe/signed/')\n-    assert res.status_code == 200\n-    signed_data_1 = res.json()\n-    assert len(signed_data_1) == 1\n-    mocked_autograph.verify_api_pair(signed_data_1[0])\n-\n-    # Make another change\n-    api_client.force_authenticate(user1)\n-    res = api_client.patch('/api/v1/recipe/{}/'.format(recipe_data_1['id']), {\n-        'extra_filter_expression': 'counter == 1',\n-    })\n-    assert res.status_code == 200\n-\n-    # The change should not be visible yet, since it isn't approved\n-    res = api_client.get('/api/v1/recipe/{}/'.format(recipe_data_1['id']))\n-    assert res.status_code == 200\n-    recipe_data_2 = res.json()\n-    assert recipe_data_2['extra_filter_expression'] == 'counter == 0'\n-\n-    # It is signed correctly\n-    res = api_client.get('/api/v1/recipe/signed/')\n-    assert res.status_code == 200\n-    signed_data_2 = res.json()\n-    assert len(signed_data_2) == 1\n-    mocked_autograph.verify_api_pair(signed_data_2[0])\n-\n-    # Request approval for the change\n-    res = api_client.post('/api/v1/recipe_revision/{}/request_approval/'\n-                          .format(recipe_data_2['latest_revision_id']))\n-    approval_data = res.json()\n-    recipe_data_2['approval_request'] = approval_data\n-    assert res.status_code == 201\n-\n-    # The change should not be visible yet, since it isn't approved\n-    res = api_client.get('/api/v1/recipe/{}/'.format(recipe_data_1['id']))\n-    assert res.status_code == 200\n-    assert res.json() == recipe_data_2\n-\n-    # It is signed correctly\n-    res = api_client.get('/api/v1/recipe/signed/')\n-    assert res.status_code == 200\n-    signed_data_3 = res.json()\n-    assert len(signed_data_3) == 1\n-    mocked_autograph.verify_api_pair(signed_data_3[0])\n-\n-    # Reject the change\n-    api_client.force_authenticate(user2)\n-    res = api_client.post('/api/v1/approval_request/{}/reject/'.format(approval_data['id']),\n-                          {'comment': 'r-'})\n-    recipe_data_2['approval_request'] = res.json()\n-    assert res.status_code == 200\n-\n-    # The change should not be visible yet, since it isn't approved\n-    res = api_client.get('/api/v1/recipe/{}/'.format(recipe_data_1['id']))\n-    assert res.status_code == 200\n-    assert res.json() == recipe_data_2\n-\n-    # It is signed correctly\n-    res = api_client.get('/api/v1/recipe/signed/')\n-    assert res.status_code == 200\n-    signed_data_4 = res.json()\n-    assert len(signed_data_4) == 1\n-    mocked_autograph.verify_api_pair(signed_data_4[0])\n-\n-    # Make a third version of the recipe\n-    api_client.force_authenticate(user1)\n-    res = api_client.patch('/api/v1/recipe/{}/'.format(recipe_data_1['id']), {\n-        'extra_filter_expression': 'counter == 2',\n-    })\n-    recipe_data_3 = res.json()\n-    assert res.status_code == 200\n-\n-    # Request approval\n-    res = api_client.post('/api/v1/recipe_revision/{}/request_approval/'\n-                          .format(recipe_data_3['latest_revision_id']))\n-    approval_data = res.json()\n-    assert res.status_code == 201\n-\n-    # Approve the change\n-    api_client.force_authenticate(user2)\n-    res = api_client.post('/api/v1/approval_request/{}/approve/'.format(approval_data['id']),\n-                          {'comment': 'r+'})\n-    assert res.status_code == 200\n-\n-    # The change should be visible now, since it is approved\n-    res = api_client.get('/api/v1/recipe/{}/'.format(recipe_data_1['id']))\n-    assert res.status_code == 200\n-    recipe_data_4 = res.json()\n-    assert recipe_data_4['extra_filter_expression'] == 'counter == 2'\n-    assert recipe_data_4['latest_revision_id'] == recipe_data_4['revision_id']\n-\n-    # It is signed correctly\n-    res = api_client.get('/api/v1/recipe/signed/')\n-    assert res.status_code == 200\n-    signed_data_5 = res.json()\n-    assert len(signed_data_5) == 1\n-    mocked_autograph.verify_api_pair(signed_data_5[0])\n+class TestApprovalFlow(object):\n+\n+    def verify_signatures(self, api_client, expected_count=None):\n+        res = api_client.get('/api/v1/recipe/signed/')\n+        assert res.status_code == 200\n+        signed_data = res.json()\n+\n+        if expected_count is not None:\n+            assert len(signed_data) == expected_count\n+\n+        for recipe_and_signature in signed_data:\n+            recipe = recipe_and_signature['recipe']\n+            expected_signature = recipe_and_signature['signature']['signature']\n+            data = canonical_json_dumps(recipe).encode()\n+            actual_signature = fake_sign([data])[0]['signature']\n+            assert actual_signature == expected_signature\n+\n+    def test_full_approval_flow(self, api_client, mocked_autograph):\n+        action = ActionFactory()\n+        user1 = UserFactory(is_superuser=True)\n+        user2 = UserFactory(is_superuser=True)\n+        api_client.force_authenticate(user1)\n+\n+        # Create a recipe\n+        res = api_client.post('/api/v1/recipe/', {\n+            'action': action.name,\n+            'arguments': {},\n+            'name': 'test recipe',\n+            'extra_filter_expression': 'counter == 0',\n+            'enabled': 'false',\n+        })\n+        assert res.status_code == 201\n+        recipe_data_0 = res.json()\n+\n+        # Request approval for it\n+        res = api_client.post('/api/v1/recipe_revision/{}/request_approval/'\n+                            .format(recipe_data_0['revision_id']))\n+        approval_data = res.json()\n+        assert res.status_code == 201\n+\n+        # The requester isn't allowed to approve a recipe\n+        res = api_client.post('/api/v1/approval_request/{}/approve/'.format(approval_data['id']),\n+                            {'comment': 'r+'})\n+        assert res.status_code == 403  # Forbidden\n+\n+        # Approve the recipe\n+        api_client.force_authenticate(user2)\n+        res = api_client.post('/api/v1/approval_request/{}/approve/'.format(approval_data['id']),\n+                            {'comment': 'r+'})\n+        assert res.status_code == 200\n+\n+        # It is now visible in the API\n+        res = api_client.get('/api/v1/recipe/{}/'.format(recipe_data_0['id']))\n+        assert res.status_code == 200\n+        recipe_data_1 = res.json()\n+        self.verify_signatures(api_client, expected_count=1)\n+\n+        # Make another change\n+        api_client.force_authenticate(user1)\n+        res = api_client.patch('/api/v1/recipe/{}/'.format(recipe_data_1['id']), {\n+            'extra_filter_expression': 'counter == 1',\n+        })\n+        assert res.status_code == 200\n+\n+        # The change should not be visible yet, since it isn't approved\n+        res = api_client.get('/api/v1/recipe/{}/'.format(recipe_data_1['id']))\n+        assert res.status_code == 200\n+        recipe_data_2 = res.json()\n+        assert recipe_data_2['extra_filter_expression'] == 'counter == 0'\n+        self.verify_signatures(api_client, expected_count=1)\n+\n+        # Request approval for the change\n+        res = api_client.post('/api/v1/recipe_revision/{}/request_approval/'\n+                            .format(recipe_data_2['latest_revision_id']))\n+        approval_data = res.json()\n+        recipe_data_2['approval_request'] = approval_data\n+        assert res.status_code == 201\n+\n+        # The change should not be visible yet, since it isn't approved\n+        res = api_client.get('/api/v1/recipe/{}/'.format(recipe_data_1['id']))\n+        assert res.status_code == 200\n+        assert res.json() == recipe_data_2\n+        self.verify_signatures(api_client, expected_count=1)\n+\n+        # Reject the change\n+        api_client.force_authenticate(user2)\n+        res = api_client.post('/api/v1/approval_request/{}/reject/'.format(approval_data['id']),\n+                            {'comment': 'r-'})\n+        recipe_data_2['approval_request'] = res.json()\n+        assert res.status_code == 200\n+\n+        # The change should not be visible yet, since it isn't approved\n+        res = api_client.get('/api/v1/recipe/{}/'.format(recipe_data_1['id']))\n+        assert res.status_code == 200\n+        assert res.json() == recipe_data_2\n+        self.verify_signatures(api_client, expected_count=1)\n+\n+        # Make a third version of the recipe\n+        api_client.force_authenticate(user1)\n+        res = api_client.patch('/api/v1/recipe/{}/'.format(recipe_data_1['id']), {\n+            'extra_filter_expression': 'counter == 2',\n+        })\n+        recipe_data_3 = res.json()\n+        assert res.status_code == 200\n+\n+        # Request approval\n+        res = api_client.post('/api/v1/recipe_revision/{}/request_approval/'\n+                            .format(recipe_data_3['latest_revision_id']))\n+        approval_data = res.json()\n+        assert res.status_code == 201\n+\n+        # Approve the change\n+        api_client.force_authenticate(user2)\n+        res = api_client.post('/api/v1/approval_request/{}/approve/'.format(approval_data['id']),\n+                            {'comment': 'r+'})\n+        assert res.status_code == 200\n+\n+        # The change should be visible now, since it is approved\n+        res = api_client.get('/api/v1/recipe/{}/'.format(recipe_data_1['id']))\n+        assert res.status_code == 200\n+        recipe_data_4 = res.json()\n+        assert recipe_data_4['extra_filter_expression'] == 'counter == 2'\n+        assert recipe_data_4['latest_revision_id'] == recipe_data_4['revision_id']\n+        self.verify_signatures(api_client, expected_count=1)\n+\n+    def test_request_and_then_unrequest(self, api_client, mocked_autograph):", "body_text": "test_cancel_approval might be a better name", "pull_request_url": "https://api.github.com/repos/mozilla/normandy/pulls/686", "url": "https://api.github.com/repos/mozilla/normandy/pulls/comments/111279893", "created_at": "2017-04-12T23:04:32Z", "author_association": "MEMBER", "body": "`test_cancel_approval` might be a better name", "updated_at": "2017-04-12T23:11:37Z", "html_url": "https://github.com/mozilla/normandy/pull/686#discussion_r111279893", "pull_request_review_id": 32513941, "_links": {"self": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/comments/111279893"}, "html": {"href": "https://github.com/mozilla/normandy/pull/686#discussion_r111279893"}, "pull_request": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/686"}}, "commit_id": "c850f730694ca3e8d4d1540a711354b888bf401a", "user": {"following_url": "https://api.github.com/users/Osmose/following{/other_user}", "events_url": "https://api.github.com/users/Osmose/events{/privacy}", "organizations_url": "https://api.github.com/users/Osmose/orgs", "url": "https://api.github.com/users/Osmose", "gists_url": "https://api.github.com/users/Osmose/gists{/gist_id}", "html_url": "https://github.com/Osmose", "subscriptions_url": "https://api.github.com/users/Osmose/subscriptions", "avatar_url": "https://avatars1.githubusercontent.com/u/193106?v=4", "repos_url": "https://api.github.com/users/Osmose/repos", "received_events_url": "https://api.github.com/users/Osmose/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/Osmose/starred{/owner}{/repo}", "site_admin": false, "login": "Osmose", "type": "User", "id": 193106, "followers_url": "https://api.github.com/users/Osmose/followers"}, "position": null, "path": "recipe-server/normandy/recipes/tests/test_api.py", "body_html": "<p><code>test_cancel_approval</code> might be a better name</p>", "original_commit_id": "752bd4acc7ce9e6401795aae78e71b9d874bbed4", "id": 111279893}