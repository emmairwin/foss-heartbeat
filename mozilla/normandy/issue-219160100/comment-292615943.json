{"body": "Reading through this, it seems odd to create `ActionSandboxManager` instances for every stage of every action. I expected that one `ActionSandboxManager` would be creating for each action, and then that would be kept and re-used for all of the stages. Something like this (though I've left out all the error and sanity checking)\r\n\r\n```\r\nlet actionManagers = actions.map(action => new ActionManager(action))\r\nfor (const manager of actionManagers) {\r\n  manager.runActionMethod('preExecution')\r\n}\r\nfor (const manager of actionManagers) {\r\n  manager.runActionMethod('action')\r\n}\r\nfor (const manager of actionManagers) {\r\n  manager.runActionMethod('postExecution')\r\n}\r\n```\r\n\r\nThis has less object churn, and it lets actions keep state in memory between stages of execution (maybe that isn't a good thing though?). It might also let us move more of the action execution management into the manager, which may simplify things. For example, if a stage fails, the manager would just refuse to run any further actions, centralizing the error handling.\r\n\r\nWhat do you think? Do you prefer the short lived action managers?", "body_text": "Reading through this, it seems odd to create ActionSandboxManager instances for every stage of every action. I expected that one ActionSandboxManager would be creating for each action, and then that would be kept and re-used for all of the stages. Something like this (though I've left out all the error and sanity checking)\nlet actionManagers = actions.map(action => new ActionManager(action))\nfor (const manager of actionManagers) {\n  manager.runActionMethod('preExecution')\n}\nfor (const manager of actionManagers) {\n  manager.runActionMethod('action')\n}\nfor (const manager of actionManagers) {\n  manager.runActionMethod('postExecution')\n}\n\nThis has less object churn, and it lets actions keep state in memory between stages of execution (maybe that isn't a good thing though?). It might also let us move more of the action execution management into the manager, which may simplify things. For example, if a stage fails, the manager would just refuse to run any further actions, centralizing the error handling.\nWhat do you think? Do you prefer the short lived action managers?", "url": "https://api.github.com/repos/mozilla/normandy/issues/comments/292615943", "created_at": "2017-04-07T18:29:53Z", "author_association": "MEMBER", "html_url": "https://github.com/mozilla/normandy/pull/659#issuecomment-292615943", "updated_at": "2017-04-07T18:29:53Z", "user": {"following_url": "https://api.github.com/users/mythmon/following{/other_user}", "events_url": "https://api.github.com/users/mythmon/events{/privacy}", "organizations_url": "https://api.github.com/users/mythmon/orgs", "url": "https://api.github.com/users/mythmon", "gists_url": "https://api.github.com/users/mythmon/gists{/gist_id}", "html_url": "https://github.com/mythmon", "subscriptions_url": "https://api.github.com/users/mythmon/subscriptions", "avatar_url": "https://avatars3.githubusercontent.com/u/305049?v=4", "repos_url": "https://api.github.com/users/mythmon/repos", "received_events_url": "https://api.github.com/users/mythmon/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/mythmon/starred{/owner}{/repo}", "site_admin": false, "login": "mythmon", "type": "User", "id": 305049, "followers_url": "https://api.github.com/users/mythmon/followers"}, "body_html": "<p>Reading through this, it seems odd to create <code>ActionSandboxManager</code> instances for every stage of every action. I expected that one <code>ActionSandboxManager</code> would be creating for each action, and then that would be kept and re-used for all of the stages. Something like this (though I've left out all the error and sanity checking)</p>\n<pre><code>let actionManagers = actions.map(action =&gt; new ActionManager(action))\nfor (const manager of actionManagers) {\n  manager.runActionMethod('preExecution')\n}\nfor (const manager of actionManagers) {\n  manager.runActionMethod('action')\n}\nfor (const manager of actionManagers) {\n  manager.runActionMethod('postExecution')\n}\n</code></pre>\n<p>This has less object churn, and it lets actions keep state in memory between stages of execution (maybe that isn't a good thing though?). It might also let us move more of the action execution management into the manager, which may simplify things. For example, if a stage fails, the manager would just refuse to run any further actions, centralizing the error handling.</p>\n<p>What do you think? Do you prefer the short lived action managers?</p>", "id": 292615943, "issue_url": "https://api.github.com/repos/mozilla/normandy/issues/659"}