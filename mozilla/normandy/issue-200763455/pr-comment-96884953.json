{"original_position": 184, "diff_hunk": "@@ -5,77 +5,121 @@\n \"use strict\";\n \n const {utils: Cu} = Components;\n-Cu.import(\"resource://shield-recipe-client/lib/LogManager.jsm\");\n+Cu.import(\"resource://gre/modules/Task.jsm\");\n Cu.importGlobalProperties([\"crypto\", \"TextEncoder\"]);\n \n this.EXPORTED_SYMBOLS = [\"Sampling\"];\n \n-const log = LogManager.getLogger(\"sampling\");\n-\n-/**\n- * Map from the range [0, 1] to [0, max(sha256)].\n- * @param  {number} frac A float from 0.0 to 1.0.\n- * @return {string} A 48 bit number represented in hex, padded to 12 characters.\n- */\n-function fractionToKey(frac) {\n-  const hashBits = 48;\n-  const hashLength = hashBits / 4;\n-\n-  if (frac < 0 || frac > 1) {\n-    throw new Error(`frac must be between 0 and 1 inclusive (got ${frac})`);\n-  }\n-\n-  const mult = Math.pow(2, hashBits) - 1;\n-  const inDecimal = Math.floor(frac * mult);\n-  let hexDigits = inDecimal.toString(16);\n-  if (hexDigits.length < hashLength) {\n-    // Left pad with zeroes\n-    // If N zeroes are needed, generate an array of nulls N+1 elements long,\n-    // and inserts zeroes between each null.\n-    hexDigits = Array(hashLength - hexDigits.length + 1).join(\"0\") + hexDigits;\n-  }\n-\n-  // Saturate at 2**48 - 1\n-  if (hexDigits.length > hashLength) {\n-    hexDigits = Array(hashLength + 1).join(\"f\");\n-  }\n-\n-  return hexDigits;\n-}\n-\n-function bufferToHex(buffer) {\n-  const hexCodes = [];\n-  const view = new DataView(buffer);\n-  for (let i = 0; i < view.byteLength; i += 4) {\n-    // Using getUint32 reduces the number of iterations needed (we process 4 bytes each time)\n-    const value = view.getUint32(i);\n-    // toString(16) will give the hex representation of the number without padding\n-    hexCodes.push(value.toString(16).padStart(8, \"0\"));\n-  }\n-\n-  // Join all the hex strings into one\n-  return hexCodes.join(\"\");\n-}\n-\n this.Sampling = {\n-  stableSample(input, rate) {\n-    const hasher = crypto.subtle;\n-\n-    return hasher.digest(\"SHA-256\", new TextEncoder(\"utf-8\").encode(JSON.stringify(input)))\n-      .then(hash => {\n-        // truncate hash to 12 characters (2^48)\n-        const inputHash = bufferToHex(hash).slice(0, 12);\n-        const samplePoint = fractionToKey(rate);\n-\n-        if (samplePoint.length !== 12 || inputHash.length !== 12) {\n-          throw new Error(\"Unexpected hash length\");\n-        }\n+  /**\n+   * Map from the range [0, 1] to [0, 2^48].\n+   * @param  {number} frac A float from 0.0 to 1.0.\n+   * @return {string} A 48 bit number represented in hex, padded to 12 characters.\n+   */\n+  fractionToKey(frac) {\n+    const hashBits = 48;\n+    const hashLength = hashBits / 4;  // each hexadecimal digit represents 4 bits\n+\n+    if (frac < 0 || frac > 1) {\n+      throw new Error(`frac must be between 0 and 1 inclusive (got ${frac})`);\n+    }\n+\n+    const mult = Math.pow(2, hashBits) - 1;\n+    const inDecimal = Math.floor(frac * mult);\n+    let hexDigits = inDecimal.toString(16);\n+    if (hexDigits.length < hashLength) {\n+      // Left pad with zeroes\n+      // If N zeroes are needed, generate an array of nulls N+1 elements long,\n+      // and inserts zeroes between each null.\n+      hexDigits = Array(hashLength - hexDigits.length + 1).join(\"0\") + hexDigits;\n+    }\n+\n+    // Saturate at 2**48 - 1\n+    if (hexDigits.length > hashLength) {\n+      hexDigits = Array(hashLength + 1).join(\"f\");\n+    }\n+\n+    return hexDigits;\n+  },\n \n-        return inputHash < samplePoint;\n+  bufferToHex(buffer) {\n+    const hexCodes = [];\n+    const view = new DataView(buffer);\n+    for (let i = 0; i < view.byteLength; i += 4) {\n+      // Using getUint32 reduces the number of iterations needed (we process 4 bytes each time)\n+      const value = view.getUint32(i);\n+      // toString(16) will give the hex representation of the number without padding\n+      hexCodes.push(value.toString(16).padStart(8, \"0\"));\n+    }\n+\n+    // Join all the hex strings into one\n+    return hexCodes.join(\"\");\n+  },\n \n-      })\n-      .catch(error => {\n-        log.error(`Error: ${error}`);\n-      });\n+  rangeBucketSample(inputHash, minBucket, maxBucket, bucketCount) {\n+    const minHash = Sampling.fractionToKey(minBucket / bucketCount);\n+    const maxHash = Sampling.fractionToKey(maxBucket / bucketCount);\n+    return (minHash <= inputHash) && (inputHash < maxHash);\n   },\n+\n+  /**\n+   * @promise A hash of `data`, truncated to the 12 most significant characters.\n+   */\n+  truncatedHash: Task.async(function* (data) {\n+    const hasher = crypto.subtle;\n+    const input = new TextEncoder(\"utf-8\").encode(JSON.stringify(data));\n+    const hash = yield hasher.digest(\"SHA-256\", input);\n+    // truncate hash to 12 characters (2^48), because the full hash is larger\n+    // than JS can meaningfully represent as a number.\n+    return Sampling.bufferToHex(hash).slice(0, 12);\n+  }),\n+\n+  /**\n+   * Sample by splitting the input into two buckets, one with a size (rate) and\n+   * another with a size (1.0 - rate), and then check if the input's hash falls\n+   * into the first bucket.\n+   *\n+   * @param    {object}  input Input to hash to determine the sample.\n+   * @param    {Number}  rate  Number between 0.0 and 1.0 to sample at. A value of\n+   *                           0.25 returns true 25% of the time.\n+   * @promises {boolean} True if the input is in the sample.\n+   */\n+  stableSample: Task.async(function* (input, rate) {\n+    const inputHash = yield Sampling.truncatedHash(input);\n+    const samplePoint = Sampling.fractionToKey(rate);\n+\n+    return inputHash < samplePoint;\n+  }),\n+\n+  /**\n+   * Sample by splitting the input space into a series of buckets, and checking\n+   * if the given input is in a range of buckets.\n+   *\n+   * The range to check is defined by a start point and length, and can wrap\n+   * around the input space. For example, if there are 100 buckets, and we ask to\n+   * check 50 buckets starting from bucket 70, then buckets 70-100 and 0-19 will\n+   * be checked.\n+   *\n+   * @param {object}     input Input to hash to determine the matching bucket.\n+   * @param {integer}    start Index of the bucket to start checking.\n+   * @param {integer}    count Number of buckets to check.\n+   * @param {integer}    total Total number of buckets to group inputs into.\n+   * @promises {boolean} True if the given input is within the range of buckets\n+   *                     we're checking. */\n+  bucketSample: Task.async(function* (input, start, count, total) {\n+    const inputHash = yield Sampling.truncatedHash(input);\n+    const wrappedStart = start % total;\n+    const end = wrappedStart + count;\n+\n+    // If the range we're testing wraps, we have to check two ranges: from start\n+    // to max, and from min to end.\n+    if (end > total) {\n+      return (\n+        Sampling.rangeBucketSample(inputHash, 0, end % total, total)\n+        || Sampling.rangeBucketSample(inputHash, wrappedStart, total, total)\n+      );\n+    }\n+\n+    return Sampling.rangeBucketSample(inputHash, wrappedStart, wrappedStart + count, total);", "body_text": "nit: use end rather than wrappedStart + count", "pull_request_url": "https://api.github.com/repos/mozilla/normandy/pulls/425", "url": "https://api.github.com/repos/mozilla/normandy/pulls/comments/96884953", "created_at": "2017-01-19T15:33:57Z", "author_association": "CONTRIBUTOR", "body": "nit: use `end` rather than `wrappedStart + count`", "updated_at": "2017-01-19T22:59:14Z", "html_url": "https://github.com/mozilla/normandy/pull/425#discussion_r96884953", "pull_request_review_id": 17481563, "_links": {"self": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/comments/96884953"}, "html": {"href": "https://github.com/mozilla/normandy/pull/425#discussion_r96884953"}, "pull_request": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/425"}}, "commit_id": "ff4e97b6526c8411c5acc8a9e86ade6ce40ae721", "user": {"following_url": "https://api.github.com/users/gijsk/following{/other_user}", "events_url": "https://api.github.com/users/gijsk/events{/privacy}", "organizations_url": "https://api.github.com/users/gijsk/orgs", "url": "https://api.github.com/users/gijsk", "gists_url": "https://api.github.com/users/gijsk/gists{/gist_id}", "html_url": "https://github.com/gijsk", "subscriptions_url": "https://api.github.com/users/gijsk/subscriptions", "avatar_url": "https://avatars3.githubusercontent.com/u/375983?v=4", "repos_url": "https://api.github.com/users/gijsk/repos", "received_events_url": "https://api.github.com/users/gijsk/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/gijsk/starred{/owner}{/repo}", "site_admin": false, "login": "gijsk", "type": "User", "id": 375983, "followers_url": "https://api.github.com/users/gijsk/followers"}, "position": null, "path": "recipe-client-addon/lib/Sampling.jsm", "body_html": "<p>nit: use <code>end</code> rather than <code>wrappedStart + count</code></p>", "original_commit_id": "1786a435ffaf0e919d8c5f928371a3c53e5e2fb2", "id": 96884953}