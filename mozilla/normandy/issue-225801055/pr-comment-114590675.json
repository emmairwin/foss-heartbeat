{"original_position": 24, "diff_hunk": "@@ -123,15 +123,19 @@ this.NormandyDriver = function(sandboxManager) {\n       return ret;\n     },\n \n-    createStorage(keyPrefix) {\n-      let storage;\n-      try {\n-        storage = Storage.makeStorage(keyPrefix, sandbox);\n-      } catch (e) {\n-        log.error(e.stack);\n-        throw e;\n+    createStorage(prefix) {\n+      const storage = new Storage(prefix);\n+\n+      // Wrapped methods that we expose to the sandbox. These are documented in\n+      // the driver spec in docs/dev/driver.rst.\n+      for (const method of [\"getItem\", \"setItem\", \"removeItem\", \"clear\"]) {\n+        storage[method] = sandboxManager.wrapAsync(storage[method], {\n+          cloneArguments: true,\n+          cloneInto: true,\n+        });\n       }\n-      return storage;\n+\n+      return sandboxManager.cloneInto(storage, {cloneFunctions: true});", "body_text": "Instead of modifying and passing the storage object directly, could we make an interface object to pass in?\nconst storage  = new Storage(prefix);\n\nconst interface = {};\nfor (const method of [\"getItem\", \"setItem\", \"removeItem\", \"clear\"]) {\n  interface[method] = sandboxManager.wrapAsync(storage[method], {\n    cloneArguments: true,\n    cloneInto: true,\n  });\n}\n\nreturn sandboxManager.cloneInto(interface, {cloneFunctions: true});\nI think this will help avoid exposing unintended functions to the sandbox. I also think that it would be better to not modify the storage object, so any this.foo method calls it makes will use unmodified versions of the methods. Would that work?", "pull_request_url": "https://api.github.com/repos/mozilla/normandy/pulls/729", "url": "https://api.github.com/repos/mozilla/normandy/pulls/comments/114590675", "created_at": "2017-05-03T16:26:26Z", "author_association": "MEMBER", "body": "Instead of modifying and passing the storage object directly, could we make an interface object to pass in?\r\n\r\n```js\r\nconst storage  = new Storage(prefix);\r\n\r\nconst interface = {};\r\nfor (const method of [\"getItem\", \"setItem\", \"removeItem\", \"clear\"]) {\r\n  interface[method] = sandboxManager.wrapAsync(storage[method], {\r\n    cloneArguments: true,\r\n    cloneInto: true,\r\n  });\r\n}\r\n\r\nreturn sandboxManager.cloneInto(interface, {cloneFunctions: true});\r\n```\r\n\r\nI think this will help avoid exposing unintended functions to the sandbox. I also think that it would be better to not modify the storage object, so any `this.foo` method calls it makes will use unmodified versions of the methods. Would that work?", "updated_at": "2017-05-04T23:25:03Z", "html_url": "https://github.com/mozilla/normandy/pull/729#discussion_r114590675", "pull_request_review_id": 36070320, "_links": {"self": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/comments/114590675"}, "html": {"href": "https://github.com/mozilla/normandy/pull/729#discussion_r114590675"}, "pull_request": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/729"}}, "commit_id": "eac03379ed27b3f1207934581204e1ae6b52a153", "user": {"following_url": "https://api.github.com/users/mythmon/following{/other_user}", "events_url": "https://api.github.com/users/mythmon/events{/privacy}", "organizations_url": "https://api.github.com/users/mythmon/orgs", "url": "https://api.github.com/users/mythmon", "gists_url": "https://api.github.com/users/mythmon/gists{/gist_id}", "html_url": "https://github.com/mythmon", "subscriptions_url": "https://api.github.com/users/mythmon/subscriptions", "avatar_url": "https://avatars3.githubusercontent.com/u/305049?v=4", "repos_url": "https://api.github.com/users/mythmon/repos", "received_events_url": "https://api.github.com/users/mythmon/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/mythmon/starred{/owner}{/repo}", "site_admin": false, "login": "mythmon", "type": "User", "id": 305049, "followers_url": "https://api.github.com/users/mythmon/followers"}, "position": null, "path": "recipe-client-addon/lib/NormandyDriver.jsm", "body_html": "<p>Instead of modifying and passing the storage object directly, could we make an interface object to pass in?</p>\n<div class=\"highlight highlight-source-js\"><pre><span class=\"pl-k\">const</span> <span class=\"pl-c1\">storage</span>  <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-en\">Storage</span>(prefix);\n\n<span class=\"pl-k\">const</span> <span class=\"pl-c1\">interface</span> <span class=\"pl-k\">=</span> {};\n<span class=\"pl-k\">for</span> (<span class=\"pl-k\">const</span> <span class=\"pl-c1\">method</span> <span class=\"pl-k\">of</span> [<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>getItem<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>setItem<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>removeItem<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>clear<span class=\"pl-pds\">\"</span></span>]) {\n  <span class=\"pl-k\">interface</span>[method] <span class=\"pl-k\">=</span> <span class=\"pl-smi\">sandboxManager</span>.<span class=\"pl-en\">wrapAsync</span>(storage[method], {\n    cloneArguments<span class=\"pl-k\">:</span> <span class=\"pl-c1\">true</span>,\n    cloneInto<span class=\"pl-k\">:</span> <span class=\"pl-c1\">true</span>,\n  });\n}\n\n<span class=\"pl-k\">return</span> <span class=\"pl-smi\">sandboxManager</span>.<span class=\"pl-en\">cloneInto</span>(<span class=\"pl-k\">interface</span>, {cloneFunctions<span class=\"pl-k\">:</span> <span class=\"pl-c1\">true</span>});</pre></div>\n<p>I think this will help avoid exposing unintended functions to the sandbox. I also think that it would be better to not modify the storage object, so any <code>this.foo</code> method calls it makes will use unmodified versions of the methods. Would that work?</p>", "original_commit_id": "ac82ded75bcfb5791488c43b378e63b303c451ca", "id": 114590675}