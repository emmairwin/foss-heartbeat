{"original_position": 350, "diff_hunk": "@@ -0,0 +1,395 @@\n+/* This Source Code Form is subject to the terms of the Mozilla Public\n+ * License, v. 2.0. If a copy of the MPL was not distributed with this\n+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */\n+\n+/**\n+ * PreferenceManagement exposes an API for recipes such as Preference Experiments\n+ * to handle manipulating default/user branch preferences. Recipes should extend\n+ * this module.\n+ *\n+ * Info on active and past recipes is stored in a JSON file in the profile\n+ * folder. Preference observers can also be tracked/instantiated/etc.\n+ */\n+\"use strict\";\n+\n+const {utils: Cu} = Components;\n+Cu.import(\"resource://gre/modules/XPCOMUtils.jsm\");\n+\n+XPCOMUtils.defineLazyModuleGetter(this, \"Services\", \"resource://gre/modules/Services.jsm\");\n+XPCOMUtils.defineLazyModuleGetter(this, \"CleanupManager\", \"resource://shield-recipe-client/lib/CleanupManager.jsm\");\n+XPCOMUtils.defineLazyModuleGetter(this, \"JSONFile\", \"resource://gre/modules/JSONFile.jsm\");\n+XPCOMUtils.defineLazyModuleGetter(this, \"OS\", \"resource://gre/modules/osfile.jsm\");\n+XPCOMUtils.defineLazyModuleGetter(this, \"LogManager\", \"resource://shield-recipe-client/lib/LogManager.jsm\");\n+XPCOMUtils.defineLazyModuleGetter(this, \"Preferences\", \"resource://gre/modules/Preferences.jsm\");\n+XPCOMUtils.defineLazyModuleGetter(this, \"TelemetryEnvironment\", \"resource://gre/modules/TelemetryEnvironment.jsm\");\n+\n+this.EXPORTED_SYMBOLS = [\"PreferenceManagement\"];\n+\n+const STORE_FILE = \"shield-preference-recipes.json\";\n+\n+const PREFERENCE_TYPE_MAP = {\n+  boolean: Services.prefs.PREF_BOOL,\n+  string: Services.prefs.PREF_STRING,\n+  integer: Services.prefs.PREF_INT,\n+};\n+\n+const DefaultPreferences = new Preferences({defaultBranch: true});\n+/**\n+ * Enum storing Preference modules for each type of preference branch.\n+ * @enum {Object}\n+ */\n+const PreferenceBranchType = {\n+  user: Preferences,\n+  default: DefaultPreferences,\n+};\n+\n+const log = LogManager.getLogger(\"preference-management\");\n+\n+this.PreferenceManagement = (namespace) => ({\n+  preferenceObservers: new Map(),\n+\n+  // Internal 'store loaded' tracking object\n+  storePromise: undefined,\n+\n+  /**\n+   * Asynchronously loads the local JSON file used for storage, returning the\n+   * request Promise.\n+   *\n+   * @returns {Promise}\n+   * @resolves When the operation is completed succesfully\n+   * @rejects Javascript exception.\n+   */\n+  ensureStorage() {\n+    if (this.storePromise === undefined) {\n+      const path = OS.Path.join(OS.Constants.Path.profileDir, STORE_FILE);\n+      const storage = new JSONFile({path});\n+      this.storePromise = storage.load().then(() => storage);\n+    }\n+    return this.storePromise;\n+  },\n+\n+  /**\n+   * Returns the internal storage object, after properly ensuring the store and\n+   * store namespace are initiated.\n+   *\n+   * @returns {Promise}\n+   * @resolves When the operation is completed succesfully\n+   * @rejects Javascript exception.\n+   */\n+  async getStorage() {\n+    const store = await this.ensureStorage();\n+    store.data = store.data || {};\n+    store.data[namespace] = store.data[namespace] || {};\n+    store.saveSoon();\n+\n+    return store;\n+  },\n+\n+  /**\n+   * Clears the namespaced storage.\n+   *\n+   * @returns {Promise}\n+   * @resolves When the operation is completed succesfully\n+   * @rejects Javascript exception.\n+   */\n+  async clearStorage() {\n+    const store = await this.getStorage();\n+    store.data[namespace] = {};\n+    store.saveSoon();\n+  },\n+\n+\n+  /**\n+   * Returns the internal storage object, after properly ensuring the store and\n+   * store namespace are initiated.\n+   *\n+   * @returns {Promise}\n+   * @resolves When the operation is completed succesfully\n+   * @rejects Javascript exception.\n+   */\n+  async setStorageItem(key, value) {\n+    const store = await this.getStorage();\n+    store.data[namespace][key] = value;\n+  },\n+\n+  /**\n+   * Test wrapper that temporarily replaces the stored recipe data with fake\n+   * data for testing. Given a test function, mocks the data store, then executes\n+   * that function.\n+   */\n+  withMockData(testFunction) {\n+    // We use a POJO to fake the internal storage.\n+    this.mockData = {\n+      [namespace]: {},\n+    };\n+\n+    return async (...args) => {\n+      this.storePromise = Promise.resolve({\n+        data: this.mockData,\n+        saveSoon() {},\n+      });\n+\n+      try {\n+        // Tests directly edit store values, so for test functions, the relevant\n+        // namespace is exposed for brevity.\n+        await testFunction(this.mockData[namespace], ...args)\n+      } finally {\n+        this.stopAllObservers();\n+\n+        // Clear up any remnants from the test function\n+        this.clearStorage();\n+\n+        // Undo the mock storage\n+        this.storePromise = undefined;\n+      }\n+\n+      // ensureStorage will use the fake `storePromise`, returning mock data.\n+      return await this.ensureStorage();\n+    };\n+  },\n+\n+  /**\n+   * Looks up active recipes in the local store that modify preference values,\n+   * and applies those changes across Default/User prefs.\n+   *\n+   * @returns {Promise}\n+   * @resolves When the operation is completed succesfully\n+   * @rejects Javascript exception.\n+   */\n+  async applyAll() {\n+    // On shutdown, clear all the observers that we're about to instantiate.\n+    CleanupManager.addCleanupHandler(this.stopAllObservers.bind(this));\n+\n+    for (const recipe of await this.getActiveChanges()) {\n+      // Select the User or Default branch, then update the recipe's preference\n+      // with the appropriate value.\n+      const prefs = this.getPreferenceBranch(recipe.preferenceBranchType);\n+      prefs.set(recipe.preferenceName, recipe.preferenceValue);\n+\n+      // Notify Telemetry of recipes we're running, since they don't persist between restarts\n+      TelemetryEnvironment.setExperimentActive(recipe.name, recipe.branch);\n+\n+      // Watch for changes to the recipe's preference\n+      this.startObserver(recipe.name, recipe.preferenceName, recipe.preferenceValue);\n+    }\n+  },\n+\n+  /**\n+   * Returns a reference to either the Default or User preferences branch\n+   *\n+   * @param  {string} which Branch to return ('user' or 'default')\n+   * @return {Object}       Selected preferences branch\n+   */\n+  getPreferenceBranch(which) {\n+    const branch = PreferenceBranchType[which];\n+    if (!branch) {\n+      throw new Error(`Invalid value for preference branch: \"${which}\"`);\n+    }\n+\n+    return branch;\n+  },\n+\n+  /**\n+   * Register a preference observer that stops an recipe when the user\n+   * modifies the preference.\n+   * @param {string} recipeName\n+   * @param {string} preferenceName\n+   * @param {string|integer|boolean} preferenceValue\n+   * @throws {Error}\n+   *   If an observer for the named recipe is already active.\n+   */\n+  startObserver(recipeName, preferenceName, preferenceValue) {\n+    log.debug(`PreferenceManagement.startObserver(${recipeName})`);\n+\n+    if (this.preferenceObservers.has(recipeName)) {\n+      throw new Error(\n+        `An observer for the preference recipe ${recipeName} is already active.`\n+      );\n+    }\n+\n+    const observerInfo = {\n+      preferenceName,\n+      observer: (newValue) => {\n+        if (newValue !== preferenceValue) {\n+          this.stop(recipeName, false);\n+        }\n+      },\n+    };\n+    this.preferenceObservers.set(recipeName, observerInfo);\n+    Preferences.observe(preferenceName, observerInfo.observer);\n+  },\n+\n+  /**\n+   * Check if a preference observer is active for an recipe.\n+   * @param {string} recipeName\n+   * @return {Boolean}\n+   */\n+  hasObserver(recipeName) {\n+    log.debug(`PreferenceManagement.hasObserver(${recipeName})`);\n+    return this.preferenceObservers.has(recipeName);\n+  },\n+\n+  /**\n+   * Disable a preference observer for the named recipe.\n+   * @param {string} recipeName\n+   * @throws {Error}\n+   *   If there is no active observer for the named recipe.\n+   */\n+  stopObserver(recipeName) {\n+    log.debug(`PreferenceManagement.stopObserver(${recipeName})`);\n+\n+    if (!this.preferenceObservers.has(recipeName)) {\n+      throw new Error(`No observer for the preference recipe ${recipeName} found.`);\n+    }\n+\n+    const {preferenceName, observer} = this.preferenceObservers.get(recipeName);\n+    Preferences.ignore(preferenceName, observer);\n+    this.preferenceObservers.delete(recipeName);\n+  },\n+\n+  /**\n+   * Disable all currently-active preference observers for recipes.\n+   */\n+  stopAllObservers() {\n+    log.debug(\"PreferenceManagement.stopAllObservers()\");\n+    for (const {preferenceName, observer} of this.preferenceObservers.values()) {\n+      Preferences.ignore(preferenceName, observer);\n+    }\n+    this.preferenceObservers.clear();\n+  },\n+\n+  /**\n+   * Update the timestamp storing when Normandy last sent a recipe for the named\n+   * recipe.\n+   * @param {string} recipeName\n+   * @rejects {Error}\n+   *   If there is no stored recipe with the given name.\n+   */\n+  async markLastSeen(recipeName) {\n+    log.debug(`PreferenceManagement.markLastSeen(${recipeName})`);\n+\n+    const store = await this.getStorage();\n+    if (!(recipeName in store.data[namespace])) {\n+      throw new Error(`Could not find a preference recipe named \"${recipeName}\"`);\n+    }\n+\n+    store.data[namespace][recipeName].lastSeen = new Date().toJSON();\n+    store.saveSoon();\n+  },\n+\n+  /**\n+   * Given a recipe name, returns the relevant stored data, if any.\n+   *\n+   * @param  {String} recipeName\n+   * @resolves When the operation is completed succesfully\n+   * @rejects {Error}\n+   *   If there is no stored recipe with the given name.\n+   */\n+  async get(recipeName) {\n+    log.debug(`PreferenceManagement.get(${recipeName})`);\n+    const store = await this.getStorage();\n+    if (!(recipeName in store.data[namespace])) {\n+      throw new Error(`Could not find a preference recipe named \"${recipeName}\"`);\n+    }\n+\n+    // Return a copy so mutating it doesn't affect the storage.\n+    return Object.assign({}, store.data[namespace][recipeName]);\n+  },\n+\n+  /**\n+   * Determines if a recipe's preference type is valid, and checks that the new\n+   * value type matches the existing preference type (if any value exists).\n+   *\n+   * @param  {Object} recipe Recipe object to analyze\n+   * @throws {Error} If preference type is invalid, or doesn't match existing type.\n+   */\n+  validateRecipePrefTypes(recipe) {\n+    const { preferenceName, preferenceType } = recipe;\n+\n+    const prevPrefType = Services.prefs.getPrefType(preferenceName);\n+    const givenPrefType = PREFERENCE_TYPE_MAP[preferenceType];\n+\n+    if (!preferenceType || !givenPrefType) {\n+      throw new Error(`Invalid preferenceType provided (given \"${preferenceType}\")`);\n+    }\n+\n+    if (prevPrefType !== Services.prefs.PREF_INVALID && prevPrefType !== givenPrefType) {\n+      throw new Error(\n+        `Previous preference value is of type \"${prevPrefType}\", but was given \"${givenPrefType}\" (${preferenceType})`\n+      );\n+    }\n+  },\n+\n+  /**\n+   * Saves a recipe object into locally-namespaced storage.\n+   *\n+   * @param  {Object} recipe    Recipe data to save into storage.\n+   * @returns {Promise}\n+   * @resolves When the operation is completed succesfully\n+   * @rejects Javascript exception.\n+   */\n+  async saveRecipeData(recipe) {\n+    log.debug(\"PreferenceManagement.saveRecipeData()\");\n+\n+    const store = await this.getStorage();\n+    store.data[namespace][recipe.name] = recipe;\n+    store.saveSoon();\n+  },\n+\n+  /**\n+   * Returns an array of stored recipe objects which are NOT expired.\n+   *\n+   * @returns {Promise}\n+   * @resolves When the operation is completed succesfully\n+   * @rejects Javascript exception.\n+   */\n+  async getActiveChanges() {\n+    log.debug(\"PreferenceManagement.getActiveChanges()\");\n+    const allPrefs = await this.getStoredRecipes();\n+    // Return copies so mutating them doesn't affect the storage.\n+    return allPrefs.filter(e => !e.expired).map(e => Object.assign({}, e));", "body_text": "Well, both are public methods, and so I think the expectation that getStoredRecipes offers you copies will need to remain reasonable in the future even if we refactor or something. We also have tests for both of these methods returning copies that don't affect the originals, so I think just making the assumption is fine - tests will save us if someone inadvertently starts violating that assumption. If you update/add comments accordingly, it seems unlikely we will break it, and not copying again does avoid doing extra work for no benefit. :-)", "in_reply_to_id": 118458018, "pull_request_url": "https://api.github.com/repos/mozilla/normandy/pulls/724", "url": "https://api.github.com/repos/mozilla/normandy/pulls/comments/118668948", "created_at": "2017-05-26T09:46:56Z", "author_association": "CONTRIBUTOR", "body": "Well, both are public methods, and so I think the expectation that `getStoredRecipes` offers you copies will need to remain reasonable in the future even if we refactor or something. We also have tests for both of these methods returning copies that don't affect the originals, so I think just making the assumption is fine - tests will save us if someone inadvertently starts violating that assumption. If you update/add comments accordingly, it seems unlikely we will break it, and not copying again does avoid doing extra work for no benefit. :-)", "updated_at": "2017-06-12T21:44:43Z", "html_url": "https://github.com/mozilla/normandy/pull/724#discussion_r118668948", "pull_request_review_id": 40483567, "_links": {"self": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/comments/118668948"}, "html": {"href": "https://github.com/mozilla/normandy/pull/724#discussion_r118668948"}, "pull_request": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/724"}}, "commit_id": "46651e36e3771d2c4d90f6529a28ef814e4d9e4b", "user": {"following_url": "https://api.github.com/users/gijsk/following{/other_user}", "events_url": "https://api.github.com/users/gijsk/events{/privacy}", "organizations_url": "https://api.github.com/users/gijsk/orgs", "url": "https://api.github.com/users/gijsk", "gists_url": "https://api.github.com/users/gijsk/gists{/gist_id}", "html_url": "https://github.com/gijsk", "subscriptions_url": "https://api.github.com/users/gijsk/subscriptions", "avatar_url": "https://avatars3.githubusercontent.com/u/375983?v=4", "repos_url": "https://api.github.com/users/gijsk/repos", "received_events_url": "https://api.github.com/users/gijsk/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/gijsk/starred{/owner}{/repo}", "site_admin": false, "login": "gijsk", "type": "User", "id": 375983, "followers_url": "https://api.github.com/users/gijsk/followers"}, "position": null, "path": "recipe-client-addon/lib/PreferenceManagement.jsm", "body_html": "<p>Well, both are public methods, and so I think the expectation that <code>getStoredRecipes</code> offers you copies will need to remain reasonable in the future even if we refactor or something. We also have tests for both of these methods returning copies that don't affect the originals, so I think just making the assumption is fine - tests will save us if someone inadvertently starts violating that assumption. If you update/add comments accordingly, it seems unlikely we will break it, and not copying again does avoid doing extra work for no benefit. :-)</p>", "original_commit_id": "56b772323bbfb68cf5f7771579c1c1d213fe33f0", "id": 118668948}