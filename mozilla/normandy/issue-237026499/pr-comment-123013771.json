{"original_position": 109, "diff_hunk": "@@ -126,6 +142,73 @@ add_task(withMockApiServer(async function test_fetchRecipes() {\n   equal(recipes[0].name, \"system-addon-test\");\n }));\n \n+add_task(async function test_fetchRecipes_canonical_mismatch() {\n+  const getApiUrl = sinon.stub(NormandyApi, \"getApiUrl\").resolves(\"http://localhost/recipes/\");\n+\n+  // Recipe is non-canonical (it has whitespace, properties are out of order)\n+  const response = new MockResponse(`[\n+    {\n+      \"recipe\": {\"b\": 1, \"a\": 2},\n+      \"signature\": {\"signature\": \"\", \"x5u\": \"\"}\n+    }\n+  ]`);\n+  const get = sinon.stub(NormandyApi, \"get\").resolves(response);\n+\n+  try {\n+    await NormandyApi.fetchRecipes();\n+    ok(false, \"fetchRecipes did not throw for canonical JSON mismatch\");\n+  } catch (err) {\n+    ok(err instanceof InvalidSignatureError, \"Error was not an InvalidSignatureError\");\n+    ok(/Canonical/.test(err), \"Error was not due to canonical JSON mismatch\");\n+  }\n+\n+  getApiUrl.restore();\n+  get.restore();\n+});\n+\n+add_task(async function test_fetchRecipes_validation_error() {\n+  const getApiUrl = sinon.stub(NormandyApi, \"getApiUrl\").resolves(\"http://localhost/recipes/\");\n+\n+  // Mock two URLs: recipes and the x5u\n+  const get = sinon.stub(NormandyApi, \"get\").callsFake(async url => {\n+    if (url.endsWith(\"recipes/\")) {\n+      return new MockResponse(CanonicalJSON.stringify([\n+        {\n+          recipe: {a: 1, b: 2},\n+          signature: {signature: \"invalidsignature\", x5u: \"http://localhost/x5u/\"},\n+        },\n+      ]));\n+    } else if (url.endsWith(\"x5u/\")) {\n+      return new MockResponse(\"certchain\");\n+    }\n+\n+    return null;\n+  });\n+\n+  // Validation should fail due to a malformed x5u and signature.\n+  try {\n+    await NormandyApi.fetchRecipes();\n+    ok(false, \"fetchRecipes did not throw for a validation error\");\n+  } catch (err) {\n+    ok(err instanceof InvalidSignatureError, \"Error was not an InvalidSignatureError\");\n+    ok(/signature/.test(err), \"Error was not due to a validation error\");\n+  }\n+\n+  getApiUrl.restore();\n+  get.restore();\n+});\n+\n+const invalidSignatureServer = makeMockApiServer(do_get_file(\"invalid_recipe_signature_api\"));", "body_text": "Signature validation can fail for two reasons:\n\nIf the data passed in is malformed (like if the x5u cert chain isn't in pem format) it throws an exception. This is what the first test handles.\nIf the data is in the correct format but the signature doesn't match the content, it returns false. This is what the second test handles.\n\nUptake has a single status for signature issues, and I used it for both of these without thinking about it too much; on one hand, we could mark malformed data problems as a server issue, but on the other hand, it's still a problem that was raised during signature verification.\nOne is done using mocking and the other isn't mostly because I wrote the mock one first, and when I wanted to write the second one, the test data was long enough that I didn't want to keep it in JS. If we care, I could have them both use a mock API server for consistency's sake.", "in_reply_to_id": 122929236, "pull_request_url": "https://api.github.com/repos/mozilla/normandy/pulls/818", "url": "https://api.github.com/repos/mozilla/normandy/pulls/comments/123013771", "created_at": "2017-06-20T15:39:42Z", "author_association": "MEMBER", "body": "Signature validation can fail for two reasons:\r\n\r\n- If the data passed in is malformed (like if the x5u cert chain isn't in pem format) it throws an exception. This is what the first test handles.\r\n- If the data is in the correct format but the signature doesn't match the content, it returns false. This is what the second test handles.\r\n\r\nUptake has a single status for signature issues, and I used it for both of these without thinking about it too much; on one hand, we could mark malformed data problems as a server issue, but on the other hand, it's still a problem that was raised during signature verification.\r\n\r\nOne is done using mocking and the other isn't mostly because I wrote the mock one first, and when I wanted to write the second one, the test data was long enough that I didn't want to keep it in JS. If we care, I could have them both use a mock API server for consistency's sake.", "updated_at": "2017-07-21T16:50:57Z", "html_url": "https://github.com/mozilla/normandy/pull/818#discussion_r123013771", "pull_request_review_id": 45178610, "_links": {"self": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/comments/123013771"}, "html": {"href": "https://github.com/mozilla/normandy/pull/818#discussion_r123013771"}, "pull_request": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/818"}}, "commit_id": "93c2a45d817d55211a5aa0ea6379d3d9f8800a8b", "user": {"following_url": "https://api.github.com/users/Osmose/following{/other_user}", "events_url": "https://api.github.com/users/Osmose/events{/privacy}", "organizations_url": "https://api.github.com/users/Osmose/orgs", "url": "https://api.github.com/users/Osmose", "gists_url": "https://api.github.com/users/Osmose/gists{/gist_id}", "html_url": "https://github.com/Osmose", "subscriptions_url": "https://api.github.com/users/Osmose/subscriptions", "avatar_url": "https://avatars1.githubusercontent.com/u/193106?v=4", "repos_url": "https://api.github.com/users/Osmose/repos", "received_events_url": "https://api.github.com/users/Osmose/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/Osmose/starred{/owner}{/repo}", "site_admin": false, "login": "Osmose", "type": "User", "id": 193106, "followers_url": "https://api.github.com/users/Osmose/followers"}, "position": null, "path": "recipe-client-addon/test/unit/test_NormandyApi.js", "body_html": "<p>Signature validation can fail for two reasons:</p>\n<ul>\n<li>If the data passed in is malformed (like if the x5u cert chain isn't in pem format) it throws an exception. This is what the first test handles.</li>\n<li>If the data is in the correct format but the signature doesn't match the content, it returns false. This is what the second test handles.</li>\n</ul>\n<p>Uptake has a single status for signature issues, and I used it for both of these without thinking about it too much; on one hand, we could mark malformed data problems as a server issue, but on the other hand, it's still a problem that was raised during signature verification.</p>\n<p>One is done using mocking and the other isn't mostly because I wrote the mock one first, and when I wanted to write the second one, the test data was long enough that I didn't want to keep it in JS. If we care, I could have them both use a mock API server for consistency's sake.</p>", "original_commit_id": "260749b2fb00e039a207680482c91bc975ee972d", "id": 123013771}