{"body_text": "Fixes #433\nI think this is ready for feedback, though I had a few questions:\n\nShould non-durable storage throw errors?\nRight now I have it set up so that when Storage is created, it seeds the durability check, and then every read/write after that it checks the durability.\n\nDoes it matter if the durability is set to 0 for each new Storage? Should it retain the existing value for any reason?\nIs it overkill to run a durability check on each read/write? On selfrepair we check on every read, fwiw.\n\n\nIs store.saveSoon() necessary to save the durability key update? I'm assuming so.\nHow should tests for this be written? There already exists a bunch of browser_Storage tests that cover storing different types of data (objects, strings, numbers, etc).\n\nCould it be as simple as creating two stores with the same namespace, and testing if they can interact with the same values?\nOn the self repair side, we simply set a value and then check if the store can read it - which doesn't necessarily seem to be a complete 'durability' check, but maybe I'm wrong.\n\n\nWhen a Storage object is created, I see a call to Cu.cloneInto(...) - does the durability seed need to happen after that step?", "labels": [], "number": 633, "assignee": {"following_url": "https://api.github.com/users/mythmon/following{/other_user}", "events_url": "https://api.github.com/users/mythmon/events{/privacy}", "organizations_url": "https://api.github.com/users/mythmon/orgs", "url": "https://api.github.com/users/mythmon", "gists_url": "https://api.github.com/users/mythmon/gists{/gist_id}", "html_url": "https://github.com/mythmon", "subscriptions_url": "https://api.github.com/users/mythmon/subscriptions", "avatar_url": "https://avatars3.githubusercontent.com/u/305049?v=4", "repos_url": "https://api.github.com/users/mythmon/repos", "received_events_url": "https://api.github.com/users/mythmon/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/mythmon/starred{/owner}{/repo}", "site_admin": false, "login": "mythmon", "type": "User", "id": 305049, "followers_url": "https://api.github.com/users/mythmon/followers"}, "repository_url": "https://api.github.com/repos/mozilla/normandy", "closed_at": "2017-04-03T16:14:22Z", "body_html": "<p><span class=\"issue-keyword tooltipped tooltipped-se\" aria-label=\"This pull request closes issue #433.\">Fixes</span> <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load issue title\" data-id=\"201707616\" data-permission-text=\"Issue title is private\" data-url=\"https://github.com/mozilla/normandy/issues/433\" href=\"https://github.com/mozilla/normandy/issues/433\">#433</a></p>\n<p>I think this is ready for feedback, though I had a few questions:</p>\n<ul>\n<li>Should non-durable storage throw errors?</li>\n<li>Right now I have it set up so that when Storage is created, it seeds the durability check, and then every read/write after that it checks the durability.\n<ul>\n<li>Does it matter if the durability is set to 0 for each new Storage? Should it retain the existing value for any reason?</li>\n<li>Is it overkill to run a durability check on each read/write? On selfrepair we check on every read, fwiw.</li>\n</ul>\n</li>\n<li>Is <code>store.saveSoon()</code> necessary to save the durability key update? I'm assuming so.</li>\n<li>How should tests for this be written? There already exists a bunch of <code>browser_Storage</code> tests that cover storing different types of data (objects, strings, numbers, etc).\n<ul>\n<li>Could it be as simple as creating two stores with the same namespace, and testing if they can interact with the same values?</li>\n<li>On the self repair side, we simply set a value and then check if the store can read it - which doesn't necessarily seem to be a complete 'durability' check, but maybe I'm wrong.</li>\n</ul>\n</li>\n<li>When a Storage object is created, I see a call to <code>Cu.cloneInto(...)</code> - does the durability seed need to happen after that step?</li>\n</ul>", "id": 216814987, "title": "addon: Add Storage durability checks (#433)", "pull_request": {"url": "https://api.github.com/repos/mozilla/normandy/pulls/633", "diff_url": "https://github.com/mozilla/normandy/pull/633.diff", "html_url": "https://github.com/mozilla/normandy/pull/633", "patch_url": "https://github.com/mozilla/normandy/pull/633.patch"}, "comments": 12, "state": "closed", "body": "Fixes #433 \r\n\r\nI think this is ready for feedback, though I had a few questions:\r\n\r\n- Should non-durable storage throw errors?\r\n- Right now I have it set up so that when Storage is created, it seeds the durability check, and then every read/write after that it checks the durability.\r\n  - Does it matter if the durability is set to 0 for each new Storage? Should it retain the existing value for any reason?\r\n  - Is it overkill to run a durability check on each read/write? On selfrepair we check on every read, fwiw.\r\n- Is `store.saveSoon()` necessary to save the durability key update? I'm assuming so.\r\n- How should tests for this be written? There already exists a bunch of `browser_Storage` tests that cover storing different types of data (objects, strings, numbers, etc). \r\n  - Could it be as simple as creating two stores with the same namespace, and testing if they can interact with the same values?\r\n  - On the self repair side, we simply set a value and then check if the store can read it - which doesn't necessarily seem to be a complete 'durability' check, but maybe I'm wrong.\r\n- When a Storage object is created, I see a call to `Cu.cloneInto(...)` - does the durability seed need to happen after that step?", "events_url": "https://api.github.com/repos/mozilla/normandy/issues/633/events", "labels_url": "https://api.github.com/repos/mozilla/normandy/issues/633/labels{/name}", "author_association": "CONTRIBUTOR", "comments_url": "https://api.github.com/repos/mozilla/normandy/issues/633/comments", "html_url": "https://github.com/mozilla/normandy/pull/633", "updated_at": "2017-09-11T15:37:24Z", "user": {"following_url": "https://api.github.com/users/andymikulski/following{/other_user}", "events_url": "https://api.github.com/users/andymikulski/events{/privacy}", "organizations_url": "https://api.github.com/users/andymikulski/orgs", "url": "https://api.github.com/users/andymikulski", "gists_url": "https://api.github.com/users/andymikulski/gists{/gist_id}", "html_url": "https://github.com/andymikulski", "subscriptions_url": "https://api.github.com/users/andymikulski/subscriptions", "avatar_url": "https://avatars1.githubusercontent.com/u/2767162?v=4", "repos_url": "https://api.github.com/users/andymikulski/repos", "received_events_url": "https://api.github.com/users/andymikulski/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/andymikulski/starred{/owner}{/repo}", "site_admin": false, "login": "andymikulski", "type": "User", "id": 2767162, "followers_url": "https://api.github.com/users/andymikulski/followers"}, "milestone": null, "locked": false, "url": "https://api.github.com/repos/mozilla/normandy/issues/633", "created_at": "2017-03-24T15:10:55Z", "assignees": [{"following_url": "https://api.github.com/users/mythmon/following{/other_user}", "events_url": "https://api.github.com/users/mythmon/events{/privacy}", "organizations_url": "https://api.github.com/users/mythmon/orgs", "url": "https://api.github.com/users/mythmon", "gists_url": "https://api.github.com/users/mythmon/gists{/gist_id}", "html_url": "https://github.com/mythmon", "subscriptions_url": "https://api.github.com/users/mythmon/subscriptions", "avatar_url": "https://avatars3.githubusercontent.com/u/305049?v=4", "repos_url": "https://api.github.com/users/mythmon/repos", "received_events_url": "https://api.github.com/users/mythmon/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/mythmon/starred{/owner}{/repo}", "site_admin": false, "login": "mythmon", "type": "User", "id": 305049, "followers_url": "https://api.github.com/users/mythmon/followers"}]}