{"original_position": 11, "diff_hunk": "@@ -50,34 +50,43 @@ buildControlField.propTypes = {\n   children: pt.node,\n };\n \n+export const CheckboxGroup = ({ name, onChange, options = [], value }) => {\n+  /**\n+   * Checkbox change event handler. Appends or removes the selected checkbox's\n+   * value to the existing `value` prop, and reports the change up to redux-form.\n+   *\n+   * @param  {Event} onChange event object\n+   */\n+  const handleChange = ({ event: target }) => {", "body_text": "Using onChange={handleChange}, where handleChange is defined in CheckboxGroup, would loop back around to the issue that handleChange is defined every render, which re-renders the subcomponents.\n\nWhich means handleChange should also be a method on a component class instead of a within a function. I think the general rule is that anonymous functions should be avoided in components, wherever they are.\n\nFurthermore, since these 'components' are not actual React Components, I'm fairly positive that the whole list is rendered regardless of what prop changes are passed in.\n\nrender (or functional components) always gets called, so there's no avoiding that. What's avoided is messing with the DOM, which is generally the much-slower part of the app. Functional components like this aren't different from class-based components in that regard.\n\nPerhaps we should actually just use React.Component and define handleChange as a component function, which would avoid all of this. This code should be sufficient.\n\nUsing the value on the input is another fine way of doing this. I think I prefer it to my own suggestion, actually. \ud83d\udc4d", "in_reply_to_id": 107212033, "pull_request_url": "https://api.github.com/repos/mozilla/normandy/pulls/595", "url": "https://api.github.com/repos/mozilla/normandy/pulls/comments/107253531", "created_at": "2017-03-21T19:31:13Z", "author_association": "MEMBER", "body": "> Using onChange={handleChange}, where handleChange is defined in CheckboxGroup, would loop back around to the issue that handleChange is defined every render, which re-renders the subcomponents.\r\n\r\nWhich means `handleChange` should also be a method on a component class instead of a within a function. I think the general rule is that anonymous functions should be avoided in components, wherever they are.\r\n\r\n> Furthermore, since these 'components' are not actual React Components, I'm fairly positive that the whole list is rendered regardless of what prop changes are passed in.\r\n\r\n`render` (or functional components) always gets called, so there's no avoiding that. What's avoided is messing with the DOM, which is generally the much-slower part of the app. Functional components like this aren't different from class-based components in that regard.\r\n\r\n> Perhaps we should actually just use React.Component and define handleChange as a component function, which would avoid all of this. This code should be sufficient.\r\n\r\nUsing the value on the input is another fine way of doing this. I think I prefer it to my own suggestion, actually. \ud83d\udc4d ", "updated_at": "2017-04-17T18:39:15Z", "html_url": "https://github.com/mozilla/normandy/pull/595#discussion_r107253531", "pull_request_review_id": 28214708, "_links": {"self": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/comments/107253531"}, "html": {"href": "https://github.com/mozilla/normandy/pull/595#discussion_r107253531"}, "pull_request": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/595"}}, "commit_id": "4fa35e564b9c52cef07a720371a94f5cd0e1de76", "user": {"following_url": "https://api.github.com/users/Osmose/following{/other_user}", "events_url": "https://api.github.com/users/Osmose/events{/privacy}", "organizations_url": "https://api.github.com/users/Osmose/orgs", "url": "https://api.github.com/users/Osmose", "gists_url": "https://api.github.com/users/Osmose/gists{/gist_id}", "html_url": "https://github.com/Osmose", "subscriptions_url": "https://api.github.com/users/Osmose/subscriptions", "avatar_url": "https://avatars1.githubusercontent.com/u/193106?v=4", "repos_url": "https://api.github.com/users/Osmose/repos", "received_events_url": "https://api.github.com/users/Osmose/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/Osmose/starred{/owner}{/repo}", "site_admin": false, "login": "Osmose", "type": "User", "id": 193106, "followers_url": "https://api.github.com/users/Osmose/followers"}, "position": null, "path": "recipe-server/client/control/components/Fields.js", "body_html": "<blockquote>\n<p>Using onChange={handleChange}, where handleChange is defined in CheckboxGroup, would loop back around to the issue that handleChange is defined every render, which re-renders the subcomponents.</p>\n</blockquote>\n<p>Which means <code>handleChange</code> should also be a method on a component class instead of a within a function. I think the general rule is that anonymous functions should be avoided in components, wherever they are.</p>\n<blockquote>\n<p>Furthermore, since these 'components' are not actual React Components, I'm fairly positive that the whole list is rendered regardless of what prop changes are passed in.</p>\n</blockquote>\n<p><code>render</code> (or functional components) always gets called, so there's no avoiding that. What's avoided is messing with the DOM, which is generally the much-slower part of the app. Functional components like this aren't different from class-based components in that regard.</p>\n<blockquote>\n<p>Perhaps we should actually just use React.Component and define handleChange as a component function, which would avoid all of this. This code should be sufficient.</p>\n</blockquote>\n<p>Using the value on the input is another fine way of doing this. I think I prefer it to my own suggestion, actually. <g-emoji class=\"g-emoji\" alias=\"+1\" fallback-src=\"https://assets-cdn.github.com/images/icons/emoji/unicode/1f44d.png\">\ud83d\udc4d</g-emoji></p>", "original_commit_id": "65730f9a28e51ced4f17c0fca9ce2303a7df050a", "id": 107253531}