{"original_position": 176, "diff_hunk": "@@ -51,88 +44,65 @@ export default class MultiPicker extends React.Component {\n       value,\n     } = this.props;\n \n-    const selectedOptions = options.filter(option =>\n-      value.indexOf(option.value) === -1);\n-\n-    let displayedOptions = [].concat(selectedOptions)\n-      .map(option => option.value)\n-      .map(val =>\n-        (!val ? null : { ...this.convertValueToObj(val) }))\n-      .filter(x => x);\n-\n     const {\n       filterText,\n     } = this.state;\n \n-    if (filterText) {\n-      displayedOptions = displayedOptions.filter(option =>\n-        JSON.stringify(option).indexOf(filterText) > -1);\n-    }\n+    let selectedOptions = options.filter(option => value.indexOf(option.value) === -1);\n \n-    return displayedOptions;\n-  }\n-\n-  handleApplyOption(event) {\n-    event.persist();\n-\n-    if (!this.availableRef) {\n-      return;\n-    }\n-\n-    const {\n-      value,\n-      onChange,\n-    } = this.props;\n-\n-    let selectedFilters = MultiPicker.getActiveSelectOptions(this.availableRef);\n+    if (filterText) {\n+      const searchText = filterText.toLowerCase();\n \n-    if (!selectedFilters || selectedFilters.length === 0) {\n-      selectedFilters = this.getDisplayedOptions();\n-      selectedFilters = selectedFilters.map(option => option.value);\n+      selectedOptions = selectedOptions.filter(option => {\n+        const searchValues = JSON.stringify(Object.values(option)).toLowerCase();\n+        return searchValues.indexOf(searchText) > -1;\n+      });\n     }\n \n-    const newOptions = []\n-      .concat(value || [])\n-      .concat(selectedFilters);\n-\n-    // clear user input\n-    this.availableRef.value = null;\n-\n-    onChange(newOptions.join(','));\n+    return selectedOptions;\n   }\n \n-  handleRemoveOption(event) {\n-    event.persist();\n-    if (!this.selectedRef) {\n-      return;\n-    }\n-\n-    const {\n-      value,\n-      onChange,\n-    } = this.props;\n+  handleTextChange(event) {\n+    const { value } = event.target;\n \n-    const selectedFilters = MultiPicker.getActiveSelectOptions(this.selectedRef);\n-    let newOptions = []\n-      .concat(value || [])\n-      .filter(val => selectedFilters.indexOf(val) === -1);\n+    this.setState({\n+      filterText: value,\n+    });\n+  }\n \n-    if (!selectedFilters || selectedFilters.length === 0) {\n-      newOptions = [];\n-    }\n+  handleChangeOption(type) {\n+    return () => {\n+      const ref = type === 'apply' ? this.availableRef : this.selectedRef;\n+      if (!type || !ref) {\n+        return;\n+      }\n \n-    // clear the user selection\n-    this.selectedRef.value = null;\n+      const {\n+        value = [],\n+        onChange = () => {},\n+      } = this.props;\n+\n+      // Get a list of all selected values.\n+      let selection = [].concat(value);\n+      // Pick up list of selected options from the dom ref\n+      const refSelected = MultiPicker.getActiveSelectOptions(ref);\n+\n+      // Apply = take from the 'available' section and put in 'selected'\n+      if (type === 'apply') {", "body_text": "Sure! Also, I was mistaken: upon further thought, making a standalone component for the option lists makes the subclassing idea unnecessary. But I'll describe it anyway.\nThe basic pattern is, wherever the behavior needs to be customized, instead of an if statement, you call another method on the class. Then, you create a subclass for each branch of the if that implements that method with the customized behavior.\nDirectly applying that to this example (and simplifying the classes a bit):\nclass Base {\n  handleChangeOption() {\n    const ref = this.getRef();\n    if (!ref) {\n      return;\n    }\n\n    const {\n      value = [],\n      onChange = () => {},\n    } = this.props;\n\n    // Get a list of all selected values.\n    let selection = [].concat(value);\n    // Pick up list of selected options from the dom ref\n    const refSelected = MultiPicker.getActiveSelectOptions(ref);\n\n    selection = this.modifySelection(selection, refSelected);\n\n    // Clear user input.\n    ref.value = null;\n\n    // Report the updated selected filters to the parent.\n    onChange(selection.join(','));\n  };\n}\n\nclass Apply extends Base {\n  getRef() {\n    return this.availableRef;\n  }\n\n  modifySelection(selection, refSelected) {\n    return selection.concat(refSelected)\n  }\n}\n\nclass Remove extends Base {\n  getRef() {\n    return this.selectedRef;\n  }\n\n  modifySelection(selection, refSelected) {\n    return selection.filter(val => refSelected.indexOf(val) === -1);\n  }\n}\nThat's not the whole story though, because you need to figure out where to actually use these two subclasses to get the customized behavior. With React, it's almost always by adding a new component.\nOne option would be to make the add and remove buttons components that share a base class. You'd have to pass the value and onChange props down to them, but that's fine.  Because the buttons themselves don't contain the lists, meaning you can't get a ref to them, you'd have to pass that down as a ref as well.\n\nStepping back, the core problem here is finding the right abstraction for what we want to do. handleChangeOptions does two things:\n\nFetches the list of options in one of the two selection boxes.\nModifies the form value of selected values by either removing or adding the selected options.\n\nActually, these are the two things that differ between adding and removing. The rest of the shared code is mostly plumbing.\nThe first item, fetching the selected options, is actually the same for both lists, just with a different ref. That's one reason why I suggested that we use a single component for both lists. The component can care all it wants about refs, and it just takes a callback that reports the selected items.\n(Although in my suggestion I recommended not using refs if you can avoid them, so \"care all it wants about refs\" isn't strictly true :P)\nIf the first item is handled, the second one is easier, because the only shared logic left is calling onChange, and one line of duplicated code is easy to read and understand.\n\nThat's a bit wordy. I've never really pair programmed before, but if my spiel above is still unclear, we can work together on writing the generic filter component so I can show you what I mean. :D", "in_reply_to_id": 106296416, "pull_request_url": "https://api.github.com/repos/mozilla/normandy/pulls/595", "url": "https://api.github.com/repos/mozilla/normandy/pulls/comments/106544324", "created_at": "2017-03-16T22:13:00Z", "author_association": "MEMBER", "body": "Sure! Also, I was mistaken: upon further thought, making a standalone component for the option lists makes the subclassing idea unnecessary. But I'll describe it anyway.\r\n\r\nThe basic pattern is, wherever the behavior needs to be customized, instead of an `if` statement, you call another method on the class. Then, you create a subclass for each branch of the `if` that implements that method with the customized behavior. \r\n\r\nDirectly applying that to this example (and simplifying the classes a bit):\r\n\r\n```js\r\nclass Base {\r\n  handleChangeOption() {\r\n    const ref = this.getRef();\r\n    if (!ref) {\r\n      return;\r\n    }\r\n\r\n    const {\r\n      value = [],\r\n      onChange = () => {},\r\n    } = this.props;\r\n\r\n    // Get a list of all selected values.\r\n    let selection = [].concat(value);\r\n    // Pick up list of selected options from the dom ref\r\n    const refSelected = MultiPicker.getActiveSelectOptions(ref);\r\n\r\n    selection = this.modifySelection(selection, refSelected);\r\n\r\n    // Clear user input.\r\n    ref.value = null;\r\n\r\n    // Report the updated selected filters to the parent.\r\n    onChange(selection.join(','));\r\n  };\r\n}\r\n\r\nclass Apply extends Base {\r\n  getRef() {\r\n    return this.availableRef;\r\n  }\r\n\r\n  modifySelection(selection, refSelected) {\r\n    return selection.concat(refSelected)\r\n  }\r\n}\r\n\r\nclass Remove extends Base {\r\n  getRef() {\r\n    return this.selectedRef;\r\n  }\r\n\r\n  modifySelection(selection, refSelected) {\r\n    return selection.filter(val => refSelected.indexOf(val) === -1);\r\n  }\r\n}\r\n```\r\n\r\nThat's not the whole story though, because you need to figure out where to actually use these two subclasses to get the customized behavior. With React, it's almost always by adding a new component. \r\n\r\nOne option would be to make the add and remove buttons components that share a base class. You'd have to pass the `value` and `onChange` props down to them, but that's fine.  Because the buttons themselves don't contain the lists, meaning you can't get a ref to them, you'd have to pass that down as a ref as well. \r\n\r\n---\r\n\r\nStepping back, the core problem here is finding the right abstraction for what we want to do. `handleChangeOptions` does two things:\r\n\r\n1. Fetches the list of options in one of the two selection boxes.\r\n2. Modifies the form value of selected values by either removing or adding the selected options.\r\n\r\nActually, these are the two things that differ between adding and removing. The rest of the shared code is mostly plumbing. \r\n\r\nThe first item, fetching the selected options, is actually the same for both lists, just with a different ref. That's one reason why [I suggested](https://github.com/mozilla/normandy/pull/595#discussion_r106298641) that we use a single component for both lists. The component can care all it wants about refs, and it just takes a callback that reports the selected items.\r\n\r\n(Although in my suggestion I recommended not using refs if you can avoid them, so \"care all it wants about refs\" isn't strictly true :P)\r\n\r\nIf the first item is handled, the second one is easier, because the only shared logic left is calling `onChange`, and one line of duplicated code is easy to read and understand.\r\n\r\n---\r\n\r\nThat's a bit wordy. I've never really pair programmed before, but if my spiel above is still unclear, we can work together on writing the generic filter component so I can show you what I mean. :D", "updated_at": "2017-04-17T18:39:15Z", "html_url": "https://github.com/mozilla/normandy/pull/595#discussion_r106544324", "pull_request_review_id": 27473094, "_links": {"self": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/comments/106544324"}, "html": {"href": "https://github.com/mozilla/normandy/pull/595#discussion_r106544324"}, "pull_request": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/595"}}, "commit_id": "4fa35e564b9c52cef07a720371a94f5cd0e1de76", "user": {"following_url": "https://api.github.com/users/Osmose/following{/other_user}", "events_url": "https://api.github.com/users/Osmose/events{/privacy}", "organizations_url": "https://api.github.com/users/Osmose/orgs", "url": "https://api.github.com/users/Osmose", "gists_url": "https://api.github.com/users/Osmose/gists{/gist_id}", "html_url": "https://github.com/Osmose", "subscriptions_url": "https://api.github.com/users/Osmose/subscriptions", "avatar_url": "https://avatars1.githubusercontent.com/u/193106?v=4", "repos_url": "https://api.github.com/users/Osmose/repos", "received_events_url": "https://api.github.com/users/Osmose/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/Osmose/starred{/owner}{/repo}", "site_admin": false, "login": "Osmose", "type": "User", "id": 193106, "followers_url": "https://api.github.com/users/Osmose/followers"}, "position": null, "path": "recipe-server/client/control/components/MultiPicker.js", "body_html": "<p>Sure! Also, I was mistaken: upon further thought, making a standalone component for the option lists makes the subclassing idea unnecessary. But I'll describe it anyway.</p>\n<p>The basic pattern is, wherever the behavior needs to be customized, instead of an <code>if</code> statement, you call another method on the class. Then, you create a subclass for each branch of the <code>if</code> that implements that method with the customized behavior.</p>\n<p>Directly applying that to this example (and simplifying the classes a bit):</p>\n<div class=\"highlight highlight-source-js\"><pre><span class=\"pl-k\">class</span> <span class=\"pl-en\">Base</span> {\n  <span class=\"pl-en\">handleChangeOption</span>() {\n    <span class=\"pl-k\">const</span> <span class=\"pl-c1\">ref</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">this</span>.<span class=\"pl-en\">getRef</span>();\n    <span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>ref) {\n      <span class=\"pl-k\">return</span>;\n    }\n\n    <span class=\"pl-k\">const</span> {\n      <span class=\"pl-c1\">value</span> <span class=\"pl-k\">=</span> [],\n      <span class=\"pl-en\">onChange</span> <span class=\"pl-k\">=</span> () <span class=\"pl-k\">=&gt;</span> {},\n    } <span class=\"pl-k\">=</span> <span class=\"pl-c1\">this</span>.<span class=\"pl-smi\">props</span>;\n\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> Get a list of all selected values.</span>\n    <span class=\"pl-k\">let</span> selection <span class=\"pl-k\">=</span> [].<span class=\"pl-c1\">concat</span>(value);\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> Pick up list of selected options from the dom ref</span>\n    <span class=\"pl-k\">const</span> <span class=\"pl-c1\">refSelected</span> <span class=\"pl-k\">=</span> <span class=\"pl-smi\">MultiPicker</span>.<span class=\"pl-en\">getActiveSelectOptions</span>(ref);\n\n    selection <span class=\"pl-k\">=</span> <span class=\"pl-c1\">this</span>.<span class=\"pl-en\">modifySelection</span>(selection, refSelected);\n\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> Clear user input.</span>\n    <span class=\"pl-smi\">ref</span>.<span class=\"pl-c1\">value</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">null</span>;\n\n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> Report the updated selected filters to the parent.</span>\n    <span class=\"pl-en\">onChange</span>(<span class=\"pl-smi\">selection</span>.<span class=\"pl-c1\">join</span>(<span class=\"pl-s\"><span class=\"pl-pds\">'</span>,<span class=\"pl-pds\">'</span></span>));\n  };\n}\n\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">Apply</span> <span class=\"pl-k\">extends</span> <span class=\"pl-e\">Base</span> {\n  <span class=\"pl-en\">getRef</span>() {\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">this</span>.<span class=\"pl-smi\">availableRef</span>;\n  }\n\n  <span class=\"pl-en\">modifySelection</span>(<span class=\"pl-smi\">selection</span>, <span class=\"pl-smi\">refSelected</span>) {\n    <span class=\"pl-k\">return</span> <span class=\"pl-smi\">selection</span>.<span class=\"pl-c1\">concat</span>(refSelected)\n  }\n}\n\n<span class=\"pl-k\">class</span> <span class=\"pl-en\">Remove</span> <span class=\"pl-k\">extends</span> <span class=\"pl-e\">Base</span> {\n  <span class=\"pl-en\">getRef</span>() {\n    <span class=\"pl-k\">return</span> <span class=\"pl-c1\">this</span>.<span class=\"pl-smi\">selectedRef</span>;\n  }\n\n  <span class=\"pl-en\">modifySelection</span>(<span class=\"pl-smi\">selection</span>, <span class=\"pl-smi\">refSelected</span>) {\n    <span class=\"pl-k\">return</span> <span class=\"pl-smi\">selection</span>.<span class=\"pl-en\">filter</span>(<span class=\"pl-smi\">val</span> <span class=\"pl-k\">=&gt;</span> <span class=\"pl-smi\">refSelected</span>.<span class=\"pl-c1\">indexOf</span>(val) <span class=\"pl-k\">===</span> <span class=\"pl-k\">-</span><span class=\"pl-c1\">1</span>);\n  }\n}</pre></div>\n<p>That's not the whole story though, because you need to figure out where to actually use these two subclasses to get the customized behavior. With React, it's almost always by adding a new component.</p>\n<p>One option would be to make the add and remove buttons components that share a base class. You'd have to pass the <code>value</code> and <code>onChange</code> props down to them, but that's fine.  Because the buttons themselves don't contain the lists, meaning you can't get a ref to them, you'd have to pass that down as a ref as well.</p>\n<hr>\n<p>Stepping back, the core problem here is finding the right abstraction for what we want to do. <code>handleChangeOptions</code> does two things:</p>\n<ol>\n<li>Fetches the list of options in one of the two selection boxes.</li>\n<li>Modifies the form value of selected values by either removing or adding the selected options.</li>\n</ol>\n<p>Actually, these are the two things that differ between adding and removing. The rest of the shared code is mostly plumbing.</p>\n<p>The first item, fetching the selected options, is actually the same for both lists, just with a different ref. That's one reason why <a href=\"https://github.com/mozilla/normandy/pull/595#discussion_r106298641\">I suggested</a> that we use a single component for both lists. The component can care all it wants about refs, and it just takes a callback that reports the selected items.</p>\n<p>(Although in my suggestion I recommended not using refs if you can avoid them, so \"care all it wants about refs\" isn't strictly true :P)</p>\n<p>If the first item is handled, the second one is easier, because the only shared logic left is calling <code>onChange</code>, and one line of duplicated code is easy to read and understand.</p>\n<hr>\n<p>That's a bit wordy. I've never really pair programmed before, but if my spiel above is still unclear, we can work together on writing the generic filter component so I can show you what I mean. :D</p>", "original_commit_id": "d86998b4c6ba6efa58e580ac84660a14920ac820", "id": 106544324}