{"body": "I talked with @MattGrimes about this a bit, and I learned a couple things:\r\n\r\n* Disable being permanent isn't actually desirable. There are times when someone will want to re-enable a recipe after disabling, and making a no-op change to the recipe in order to do so is not great.\r\n* The current flow of approve and then enable, with two key approval and single user enable/disable works well.\r\n\r\nThis makes me think that having many `EnabledStates` per revision might actually be what we want. As long as we expose all the enabled states in the API, instead of only the latest, it should work. I think?\r\n\r\nI was also concerned about having multiple histories (when a revision was created and when it was enabled/disabled being separate event streams), but thinking about it more, we already have this in the form of approval. I don't think it's an issue anymore, after some more thought.\r\n\r\nAll of that is to say, f+. I think the design of this can work, as long as we have the right data exposed in the API, and don't introduce any major performance problems. It nicely maintains our current semantics, while adding the extra data needed.", "body_text": "I talked with @MattGrimes about this a bit, and I learned a couple things:\n\nDisable being permanent isn't actually desirable. There are times when someone will want to re-enable a recipe after disabling, and making a no-op change to the recipe in order to do so is not great.\nThe current flow of approve and then enable, with two key approval and single user enable/disable works well.\n\nThis makes me think that having many EnabledStates per revision might actually be what we want. As long as we expose all the enabled states in the API, instead of only the latest, it should work. I think?\nI was also concerned about having multiple histories (when a revision was created and when it was enabled/disabled being separate event streams), but thinking about it more, we already have this in the form of approval. I don't think it's an issue anymore, after some more thought.\nAll of that is to say, f+. I think the design of this can work, as long as we have the right data exposed in the API, and don't introduce any major performance problems. It nicely maintains our current semantics, while adding the extra data needed.", "url": "https://api.github.com/repos/mozilla/normandy/issues/comments/370879817", "created_at": "2018-03-06T18:27:09Z", "author_association": "MEMBER", "html_url": "https://github.com/mozilla/normandy/pull/1203#issuecomment-370879817", "updated_at": "2018-03-06T18:27:09Z", "user": {"following_url": "https://api.github.com/users/mythmon/following{/other_user}", "events_url": "https://api.github.com/users/mythmon/events{/privacy}", "organizations_url": "https://api.github.com/users/mythmon/orgs", "url": "https://api.github.com/users/mythmon", "gists_url": "https://api.github.com/users/mythmon/gists{/gist_id}", "html_url": "https://github.com/mythmon", "subscriptions_url": "https://api.github.com/users/mythmon/subscriptions", "avatar_url": "https://avatars3.githubusercontent.com/u/305049?v=4", "repos_url": "https://api.github.com/users/mythmon/repos", "received_events_url": "https://api.github.com/users/mythmon/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/mythmon/starred{/owner}{/repo}", "site_admin": false, "login": "mythmon", "type": "User", "id": 305049, "followers_url": "https://api.github.com/users/mythmon/followers"}, "body_html": "<p>I talked with <a class=\"user-mention\" href=\"https://github.com/mattgrimes\">@MattGrimes</a> about this a bit, and I learned a couple things:</p>\n<ul>\n<li>Disable being permanent isn't actually desirable. There are times when someone will want to re-enable a recipe after disabling, and making a no-op change to the recipe in order to do so is not great.</li>\n<li>The current flow of approve and then enable, with two key approval and single user enable/disable works well.</li>\n</ul>\n<p>This makes me think that having many <code>EnabledStates</code> per revision might actually be what we want. As long as we expose all the enabled states in the API, instead of only the latest, it should work. I think?</p>\n<p>I was also concerned about having multiple histories (when a revision was created and when it was enabled/disabled being separate event streams), but thinking about it more, we already have this in the form of approval. I don't think it's an issue anymore, after some more thought.</p>\n<p>All of that is to say, f+. I think the design of this can work, as long as we have the right data exposed in the API, and don't introduce any major performance problems. It nicely maintains our current semantics, while adding the extra data needed.</p>", "id": 370879817, "issue_url": "https://api.github.com/repos/mozilla/normandy/issues/1203"}