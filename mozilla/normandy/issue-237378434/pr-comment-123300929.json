{"original_position": 63, "diff_hunk": "@@ -31,38 +25,35 @@ export default class PreferenceExperimentAction extends Action {\n     // Exit early if we're on an incompatible client.\n     if (experiments === undefined) {\n       this.normandy.log('Client does not support preference experiments, aborting.', 'info');\n-      return Promise.resolve();\n+      return;\n     }\n \n     seenExperimentNames.push(slug);\n-    return experiments.has(slug).then(hasSlug => {\n-      // If the experiment doesn't exist yet, enroll!\n-      if (!hasSlug) {\n-        return this.chooseBranch(branches).then(branch =>\n-          experiments.start({\n-            name: slug,\n-            branch: branch.slug,\n-            preferenceName,\n-            preferenceValue: branch.value,\n-            preferenceBranchType,\n-            preferenceType,\n-          })\n-        );\n-      }\n-\n-      // If the experiment exists, and isn't expired, bump the lastSeen date.\n-      return experiments.get(slug).then(experiment => {\n-        if (experiment.expired) {\n-          this.normandy.log(`Experiment ${slug} has expired, aborting.`, 'debug');\n-          return true;\n-        }\n \n-        return experiments.markLastSeen(slug);\n+    // If the experiment doesn't exist yet, enroll!\n+    const hasSlug = await experiments.has(slug);\n+    if (!hasSlug) {\n+      const branch = await this.chooseBranch(branches);\n+      await experiments.start({\n+        name: slug,\n+        branch: branch.slug,\n+        preferenceName,\n+        preferenceValue: branch.value,\n+        preferenceBranchType,\n+        preferenceType,\n       });\n-    });\n+    } else {\n+      // If the experiment exists, and isn't expired, bump the lastSeen date.\n+      const experiment = await experiments.get(slug);\n+      if (experiment.expired) {", "body_text": "It might be worth it! I have opinions about this that I haven't really articulated before.\nI run into situations like this a lot (a complex conditional that could split into a few standalone functions) and what I've found is that moving parts of the conditional into standalone functions is less comprehensible most of the time. The reason is that the purpose of the function containing the larger conditional is generally to dispatch to one or more smaller operations.\nHere, execute's purpose can be viewed as \"given the client state, what should we do about this preference experiment?\". Moving part of the conditional into another function makes it harder to understand how this dispatch will end up, because now you need to look at two functions to determine what choice will be made. It's like a state machine where you can only see half of the nodes at a given time and need to swap between the two ends.\nWhat I usually do (and tried to do here), is to factor out the action that you end up taking into standalone functions, but keep the conditional checking in the main function. Sometimes (and this might be an appropriate place) it's also worth it to factor out the condition into a standalone function while keeping the conditional itself in the main function. Like this:\n} else if (!(await this.isExpired(slug))) {\n  await experiments.markLastSeen(slug);\n} else {\n  this.normandy.log(`Experiment ${slug} has expired, aborting.`, 'debug');\n}\nOne less level of indentation makes it more readable, and it's pretty easy to name the function such that the conditional is understandable. I was kinda iffy on the ! in front of the await though; I've never liked !(await blah) vs !await blah. I didn't give it much more thought and just went with what's here.\nFor the same reasons, I also generally prefer having a full if statement with an else even if the if has a return inside, but our linter currently doesn't like that so I don't do it as often.\nWhat do you think? Should we go with the alternative, what's there, or do you still like your suggestion?", "in_reply_to_id": 123260914, "pull_request_url": "https://api.github.com/repos/mozilla/normandy/pulls/822", "url": "https://api.github.com/repos/mozilla/normandy/pulls/comments/123300929", "created_at": "2017-06-21T16:34:31Z", "author_association": "MEMBER", "body": "It might be worth it! I have opinions about this that I haven't really articulated before.\r\n\r\nI run into situations like this a lot (a complex conditional that could split into a few standalone functions) and what I've found is that moving parts of the conditional into standalone functions is less comprehensible most of the time. The reason is that the purpose of the function containing the larger conditional is generally to dispatch to one or more smaller operations. \r\n\r\nHere, `execute`'s purpose can be viewed as \"given the client state, what should we do about this preference experiment?\". Moving part of the conditional into another function makes it harder to understand how this dispatch will end up, because now you need to look at two functions to determine what choice will be made. It's like a state machine where you can only see half of the nodes at a given time and need to swap between the two ends.\r\n\r\nWhat I usually do (and tried to do here), is to factor out the action that you end up taking into standalone functions, but keep the conditional checking in the main function. Sometimes (and this might be an appropriate place) it's also worth it to factor out the condition into a standalone function while keeping the conditional itself in the main function. Like this:\r\n\r\n```js\r\n} else if (!(await this.isExpired(slug))) {\r\n  await experiments.markLastSeen(slug);\r\n} else {\r\n  this.normandy.log(`Experiment ${slug} has expired, aborting.`, 'debug');\r\n}\r\n```\r\n\r\nOne less level of indentation makes it more readable, and it's pretty easy to name the function such that the conditional is understandable. I was kinda iffy on the `!` in front of the await though; I've never liked `!(await blah)` vs `!await blah`. I didn't give it much more thought and just went with what's here.\r\n\r\nFor the same reasons, I also generally prefer having a full `if` statement with an `else` even if the `if` has a return inside, but our linter currently doesn't like that so I don't do it as often.\r\n\r\nWhat do you think? Should we go with the alternative, what's there, or do you still like your suggestion?", "updated_at": "2017-06-27T17:34:54Z", "html_url": "https://github.com/mozilla/normandy/pull/822#discussion_r123300929", "pull_request_review_id": 45490924, "_links": {"self": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/comments/123300929"}, "html": {"href": "https://github.com/mozilla/normandy/pull/822#discussion_r123300929"}, "pull_request": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/822"}}, "commit_id": "514c9308346f8b28ab2ae59db2d9ab6810487d3e", "user": {"following_url": "https://api.github.com/users/Osmose/following{/other_user}", "events_url": "https://api.github.com/users/Osmose/events{/privacy}", "organizations_url": "https://api.github.com/users/Osmose/orgs", "url": "https://api.github.com/users/Osmose", "gists_url": "https://api.github.com/users/Osmose/gists{/gist_id}", "html_url": "https://github.com/Osmose", "subscriptions_url": "https://api.github.com/users/Osmose/subscriptions", "avatar_url": "https://avatars1.githubusercontent.com/u/193106?v=4", "repos_url": "https://api.github.com/users/Osmose/repos", "received_events_url": "https://api.github.com/users/Osmose/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/Osmose/starred{/owner}{/repo}", "site_admin": false, "login": "Osmose", "type": "User", "id": 193106, "followers_url": "https://api.github.com/users/Osmose/followers"}, "position": 73, "path": "recipe-server/client/actions/preference-experiment/index.js", "body_html": "<p>It might be worth it! I have opinions about this that I haven't really articulated before.</p>\n<p>I run into situations like this a lot (a complex conditional that could split into a few standalone functions) and what I've found is that moving parts of the conditional into standalone functions is less comprehensible most of the time. The reason is that the purpose of the function containing the larger conditional is generally to dispatch to one or more smaller operations.</p>\n<p>Here, <code>execute</code>'s purpose can be viewed as \"given the client state, what should we do about this preference experiment?\". Moving part of the conditional into another function makes it harder to understand how this dispatch will end up, because now you need to look at two functions to determine what choice will be made. It's like a state machine where you can only see half of the nodes at a given time and need to swap between the two ends.</p>\n<p>What I usually do (and tried to do here), is to factor out the action that you end up taking into standalone functions, but keep the conditional checking in the main function. Sometimes (and this might be an appropriate place) it's also worth it to factor out the condition into a standalone function while keeping the conditional itself in the main function. Like this:</p>\n<div class=\"highlight highlight-source-js\"><pre>} <span class=\"pl-k\">else</span> <span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>(<span class=\"pl-k\">await</span> <span class=\"pl-c1\">this</span>.<span class=\"pl-en\">isExpired</span>(slug))) {\n  <span class=\"pl-k\">await</span> <span class=\"pl-smi\">experiments</span>.<span class=\"pl-en\">markLastSeen</span>(slug);\n} <span class=\"pl-k\">else</span> {\n  <span class=\"pl-c1\">this</span>.<span class=\"pl-smi\">normandy</span>.<span class=\"pl-en\">log</span>(<span class=\"pl-s\"><span class=\"pl-pds\">`</span>Experiment <span class=\"pl-s1\"><span class=\"pl-pse\">${</span>slug<span class=\"pl-pse\">}</span></span> has expired, aborting.<span class=\"pl-pds\">`</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">'</span>debug<span class=\"pl-pds\">'</span></span>);\n}</pre></div>\n<p>One less level of indentation makes it more readable, and it's pretty easy to name the function such that the conditional is understandable. I was kinda iffy on the <code>!</code> in front of the await though; I've never liked <code>!(await blah)</code> vs <code>!await blah</code>. I didn't give it much more thought and just went with what's here.</p>\n<p>For the same reasons, I also generally prefer having a full <code>if</code> statement with an <code>else</code> even if the <code>if</code> has a return inside, but our linter currently doesn't like that so I don't do it as often.</p>\n<p>What do you think? Should we go with the alternative, what's there, or do you still like your suggestion?</p>", "original_commit_id": "e2276bef4d1a6dd0d44d1d5a01f65fc3cbb282e4", "id": 123300929}