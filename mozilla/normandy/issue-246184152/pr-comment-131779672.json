{"original_position": 133, "diff_hunk": "@@ -145,20 +153,67 @@ this.NormandyApi = {\n \n   /**\n    * Fetch an array of available actions from the server.\n+   * @param filters\n+   * @param filters.enabled {boolean} If true, only returns enabled\n+   * recipes. Default true.\n    * @resolves {Array}\n    */\n-  async fetchActions() {\n-    const actionApiUrl = await this.getApiUrl(\"action-list\");\n-    const res = await this.get(actionApiUrl);\n-    return res.json();\n+  async fetchRecipes(filters = {enabled: true}) {\n+    return this.fetchSignedObjects(\"recipe\", filters);\n+  },\n+\n+  /**\n+   * Fetch an array of available actions from the server.\n+   * @resolves {Array}\n+   */\n+  async fetchActions(filters = {}) {\n+    return this.fetchSignedObjects(\"action\", filters);\n   },\n \n   async fetchImplementation(action) {\n-    const response = await fetch(action.implementation_url);\n-    if (response.ok) {\n-      return response.text();\n+    const implementationUrl = new URL(this.absolutify(action.implementation_url));\n+\n+    // fetch implementation\n+    const response = await fetch(implementationUrl);\n+    if (!response.ok) {\n+      throw new Error(\n+        `Failed to fetch action implementation for ${action.name}: ${response.status}`\n+      );\n+    }\n+    const responseText = await response.text();\n+\n+    // Try to verify integrity of the implementation text.  If the\n+    // integrity value doesn't match the content or uses an unknown\n+    // algorithm, fail.\n+\n+    // Get the last non-empty portion of the url path, and split it\n+    // into two to get the aglorithm and hash.\n+    const parts = implementationUrl.pathname.split(\"/\");\n+    const lastNonEmpty = parts.filter(p => p !== \"\").slice(-1)[0];\n+    const [algorithm, ...hashParts] = lastNonEmpty.split(\"-\");\n+    const expectedHash = hashParts.join(\"-\");\n+\n+    if (algorithm !== \"sha384\") {\n+      throw new Error(\n+        `Failed to fetch action implemenation for ${action.name}: ` +\n+        `Unexpected integrity algorithm, expected \"sha384\", got ${algorithm}`\n+      );\n+    }\n+\n+    // verify integrity hash\n+    const hasher = Cc[\"@mozilla.org/security/hash;1\"].createInstance(Ci.nsICryptoHash);\n+    hasher.init(hasher.SHA384);\n+    const dataToHash = new TextEncoder().encode(responseText);\n+    hasher.update(dataToHash, dataToHash.length);\n+    const useBase64 = true;\n+    const hash = hasher.finish(useBase64).replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n+    if (hash !== expectedHash) {", "body_text": "Using proper crypto practices here might be a good idea, though I hesitate to bring in another library for this. I also expect that that particular  library won't work well in Firefox.\nI don't think the savings from not reencoding in base64 are useful, because we would have to decode from base64 in order to do binary comparison. Either way we are doing a conversion.", "in_reply_to_id": 131760518, "pull_request_url": "https://api.github.com/repos/mozilla/normandy/pulls/934", "url": "https://api.github.com/repos/mozilla/normandy/pulls/comments/131779672", "created_at": "2017-08-07T22:25:51Z", "author_association": "MEMBER", "body": "Using proper crypto practices here might be a good idea, though I hesitate to bring in another library for this. I also expect that that particular  library won't work well in Firefox.\r\n\r\nI don't think the savings from not reencoding in base64 are useful, because we would have to decode from base64 in order to do binary comparison. Either way we are doing a conversion.", "updated_at": "2017-08-09T17:29:37Z", "html_url": "https://github.com/mozilla/normandy/pull/934#discussion_r131779672", "pull_request_review_id": 54791962, "_links": {"self": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/comments/131779672"}, "html": {"href": "https://github.com/mozilla/normandy/pull/934#discussion_r131779672"}, "pull_request": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/934"}}, "commit_id": "9b11c6f569d0e9e3d25e024a14c775e0184ba9b7", "user": {"following_url": "https://api.github.com/users/mythmon/following{/other_user}", "events_url": "https://api.github.com/users/mythmon/events{/privacy}", "organizations_url": "https://api.github.com/users/mythmon/orgs", "url": "https://api.github.com/users/mythmon", "gists_url": "https://api.github.com/users/mythmon/gists{/gist_id}", "html_url": "https://github.com/mythmon", "subscriptions_url": "https://api.github.com/users/mythmon/subscriptions", "avatar_url": "https://avatars3.githubusercontent.com/u/305049?v=4", "repos_url": "https://api.github.com/users/mythmon/repos", "received_events_url": "https://api.github.com/users/mythmon/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/mythmon/starred{/owner}{/repo}", "site_admin": false, "login": "mythmon", "type": "User", "id": 305049, "followers_url": "https://api.github.com/users/mythmon/followers"}, "position": 133, "path": "recipe-client-addon/lib/NormandyApi.jsm", "body_html": "<p>Using proper crypto practices here might be a good idea, though I hesitate to bring in another library for this. I also expect that that particular  library won't work well in Firefox.</p>\n<p>I don't think the savings from not reencoding in base64 are useful, because we would have to decode from base64 in order to do binary comparison. Either way we are doing a conversion.</p>", "original_commit_id": "276fd5fbb89f000267cede859a3f01dbbaecd9dc", "id": 131779672}