{"original_position": 66, "diff_hunk": "@@ -46,3 +53,53 @@ def deterministic_sample(rate, inputs):\n     assert len(input_hash) == 64\n \n     return input_hash < sample_point\n+\n+\n+class Autographer:\n+    \"\"\"\n+    Interacts with an Autograph service.\n+\n+    If Autograph signing is not configured using `settings.AUTOGRAPH`,\n+    raises `ImproperlyConfigured`. If the Autograph server can't be reached\n+    or returns an HTTP error, an error will be thrown by `requests`.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.check_config()\n+        self._session = None\n+\n+    @property\n+    def session(self):\n+        if self._session is None:\n+            self._session = requests.Session()\n+            self._session.auth = HawkAuth(\n+                id=str(settings.AUTOGRAPH['HAWK_ID']),\n+                key=str(settings.AUTOGRAPH['HAWK_SECRET_KEY']))\n+        return self._session\n+\n+    def check_config(self):\n+        required_keys = ['URL', 'HAWK_ID', 'HAWK_SECRET_KEY']\n+        for key in required_keys:\n+            if settings.AUTOGRAPH.get(key) is None:\n+                msg = 'set settings.AUTOGRAPH[\"{}\"] to use action signatures'.format(key)\n+                raise ImproperlyConfigured(msg)\n+\n+    def sign_data(self, content_list):\n+        \"\"\"\n+        Fetches content-signatures from Autograph for each item in `content_list`.\n+        \"\"\"\n+        url = '{URL}sign/data'.format(**settings.AUTOGRAPH)\n+        signing_request = []\n+        for item in content_list:\n+            # base64 works in bytes. requests work in UTF-8.\n+            # Convert to bytes, and then back.\n+            encoded_implementation = base64.b64encode(item.encode('utf8')).decode('utf8')\n+            signing_request.append({\n+                'template': 'content-signature',\n+                'input': encoded_implementation,\n+            })\n+\n+        res = self.session.post(url, json=signing_request)\n+        res.raise_for_status()\n+        signing_responses = res.json()\n+        return [res['content-signature'] for res in signing_responses]", "body_text": "r+", "pull_request_url": "https://api.github.com/repos/mozilla/normandy/pulls/145", "url": "https://api.github.com/repos/mozilla/normandy/pulls/comments/63403592", "created_at": "2016-05-16T18:44:31Z", "author_association": "CONTRIBUTOR", "body": "r+\n", "updated_at": "2016-05-16T21:53:55Z", "html_url": "https://github.com/mozilla/normandy/pull/145#discussion_r63403592", "pull_request_review_id": null, "_links": {"self": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/comments/63403592"}, "html": {"href": "https://github.com/mozilla/normandy/pull/145#discussion_r63403592"}, "pull_request": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/145"}}, "commit_id": "a2c6ea003e675401a55e743f7a6060baa0ac59f4", "user": {"following_url": "https://api.github.com/users/jvehent/following{/other_user}", "events_url": "https://api.github.com/users/jvehent/events{/privacy}", "organizations_url": "https://api.github.com/users/jvehent/orgs", "url": "https://api.github.com/users/jvehent", "gists_url": "https://api.github.com/users/jvehent/gists{/gist_id}", "html_url": "https://github.com/jvehent", "subscriptions_url": "https://api.github.com/users/jvehent/subscriptions", "avatar_url": "https://avatars1.githubusercontent.com/u/415617?v=4", "repos_url": "https://api.github.com/users/jvehent/repos", "received_events_url": "https://api.github.com/users/jvehent/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/jvehent/starred{/owner}{/repo}", "site_admin": false, "login": "jvehent", "type": "User", "id": 415617, "followers_url": "https://api.github.com/users/jvehent/followers"}, "position": 66, "path": "normandy/recipes/utils.py", "body_html": "<p>r+</p>", "original_commit_id": "34e082b9fd2322484a73b61b2bebb1e3408fcd97", "id": 63403592}