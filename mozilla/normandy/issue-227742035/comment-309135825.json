{"body": "The nginx oddness is gone, the root cause was fixed.\r\n\r\nIt was caused by: \r\n\r\nnormandy returned a 301 to https (which got cached for 1 hour, then served from stale cache) for a request that was already on https, on a path that was not supposed to be cached. This happened on about 10 of 30 running servers.\r\n\r\nif nginx has no cache for a url, it passes it through. if nginx has a valid cache, it serves the cached response. if nginx has a stale cache for a url, it will pass the first request through, and return the cached response to all following requests until the passed request completes. When the passed request completes, if the response would get cached the cache is updated. If the response would not get cached, then nginx will continue the pattern for serving a stale cache indefinitely. the 301s in question were served from stale cache indefinitely, causing this issue. ", "body_text": "The nginx oddness is gone, the root cause was fixed.\nIt was caused by:\nnormandy returned a 301 to https (which got cached for 1 hour, then served from stale cache) for a request that was already on https, on a path that was not supposed to be cached. This happened on about 10 of 30 running servers.\nif nginx has no cache for a url, it passes it through. if nginx has a valid cache, it serves the cached response. if nginx has a stale cache for a url, it will pass the first request through, and return the cached response to all following requests until the passed request completes. When the passed request completes, if the response would get cached the cache is updated. If the response would not get cached, then nginx will continue the pattern for serving a stale cache indefinitely. the 301s in question were served from stale cache indefinitely, causing this issue.", "url": "https://api.github.com/repos/mozilla/normandy/issues/comments/309135825", "created_at": "2017-06-16T21:14:38Z", "author_association": "CONTRIBUTOR", "html_url": "https://github.com/mozilla/normandy/issues/753#issuecomment-309135825", "updated_at": "2017-06-16T21:14:38Z", "user": {"following_url": "https://api.github.com/users/relud/following{/other_user}", "events_url": "https://api.github.com/users/relud/events{/privacy}", "organizations_url": "https://api.github.com/users/relud/orgs", "url": "https://api.github.com/users/relud", "gists_url": "https://api.github.com/users/relud/gists{/gist_id}", "html_url": "https://github.com/relud", "subscriptions_url": "https://api.github.com/users/relud/subscriptions", "avatar_url": "https://avatars0.githubusercontent.com/u/433717?v=4", "repos_url": "https://api.github.com/users/relud/repos", "received_events_url": "https://api.github.com/users/relud/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/relud/starred{/owner}{/repo}", "site_admin": false, "login": "relud", "type": "User", "id": 433717, "followers_url": "https://api.github.com/users/relud/followers"}, "body_html": "<p>The nginx oddness is gone, the root cause was fixed.</p>\n<p>It was caused by:</p>\n<p>normandy returned a 301 to https (which got cached for 1 hour, then served from stale cache) for a request that was already on https, on a path that was not supposed to be cached. This happened on about 10 of 30 running servers.</p>\n<p>if nginx has no cache for a url, it passes it through. if nginx has a valid cache, it serves the cached response. if nginx has a stale cache for a url, it will pass the first request through, and return the cached response to all following requests until the passed request completes. When the passed request completes, if the response would get cached the cache is updated. If the response would not get cached, then nginx will continue the pattern for serving a stale cache indefinitely. the 301s in question were served from stale cache indefinitely, causing this issue.</p>", "id": 309135825, "issue_url": "https://api.github.com/repos/mozilla/normandy/issues/753"}