{"original_position": 41, "diff_hunk": "@@ -186,10 +187,39 @@ this.PreferenceExperiments = {\n       lastSeen: new Date().toJSON(),\n       preferenceName,\n       preferenceValue,\n+      preferenceType,\n       previousPreferenceValue: preferences.get(preferenceName, undefined),\n       preferenceBranchType,\n     };\n \n+    // If there's a previous preference value set, we need to ensure that the\n+    // incoming value is of the same type.\n+    if (preferences.has(preferenceName)) {\n+      // get the previous type in PREF_ form\n+      const previousType = Services.prefs.getPrefType(preferenceName);\n+\n+      let argumentValueType = preferenceType;\n+      const typeConversions = {\n+        boolean: Services.prefs.PREF_BOOL,\n+        string: Services.prefs.PREF_STRING,\n+        integer: Services.prefs.PREF_INT,\n+      };\n+\n+      // Default to an INVALID pref type, unless there is a key in the typeConversions\n+      // that matches the given argument type\n+      let givenType = Services.prefs.PREF_INVALID || 0;", "body_text": "With this PREF_INVALID and hasOwnProperty check, if a user gives an invalid preference type, one of two things may happen:\n\nIf the preference has an existing value, the type check will fail and claim that it was expecting an invalid-typed preference. This is difficult to debug, because that error doesn't clearly indicate that the problem is a malformed preference type coming from the arguments.\nIf the preference doesn't have an existing value, the type check will pass. Since nothing fails, we can't detect this, despite the preference type being incorrect.\n\nTo make it easier for developers to catch problems with malformed preference types (which we type-check on the server using JSON schema anyway), we should check if the preference type is in the list near the start of the function and throw an error if it isn't. Then you can just check succinctly:\nconst existingPreferenceType = Services.prefs.getPrefType(preferenceName);\nif (existingPreferenceType !== PREFERENCE_TYPE_MAP[preferenceType]) {\n\n}", "in_reply_to_id": 112019894, "pull_request_url": "https://api.github.com/repos/mozilla/normandy/pulls/673", "url": "https://api.github.com/repos/mozilla/normandy/pulls/comments/112110972", "created_at": "2017-04-19T03:52:35Z", "author_association": "MEMBER", "body": "With this `PREF_INVALID` and `hasOwnProperty` check, if a user gives an invalid preference type, one of two things may happen:\r\n\r\n1. If the preference has an existing value, the type check will fail and claim that it was expecting an invalid-typed preference. This is difficult to debug, because that error doesn't clearly indicate that the problem is a malformed preference type coming from the arguments.\r\n2. If the preference doesn't have an existing value, the type check will pass. Since nothing fails, we can't detect this, despite the preference type being incorrect.\r\n\r\nTo make it easier for developers to catch problems with malformed preference types (which we type-check on the server using JSON schema anyway), we should check if the preference type is in the list near the start of the function and throw an error if it isn't. Then you can just check succinctly:\r\n\r\n```js\r\nconst existingPreferenceType = Services.prefs.getPrefType(preferenceName);\r\nif (existingPreferenceType !== PREFERENCE_TYPE_MAP[preferenceType]) {\r\n\r\n}\r\n```", "updated_at": "2017-04-20T14:39:26Z", "html_url": "https://github.com/mozilla/normandy/pull/673#discussion_r112110972", "pull_request_review_id": 33399415, "_links": {"self": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/comments/112110972"}, "html": {"href": "https://github.com/mozilla/normandy/pull/673#discussion_r112110972"}, "pull_request": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/673"}}, "commit_id": "0481af5b14c3a214840bcb56387fdf293f7386a8", "user": {"following_url": "https://api.github.com/users/Osmose/following{/other_user}", "events_url": "https://api.github.com/users/Osmose/events{/privacy}", "organizations_url": "https://api.github.com/users/Osmose/orgs", "url": "https://api.github.com/users/Osmose", "gists_url": "https://api.github.com/users/Osmose/gists{/gist_id}", "html_url": "https://github.com/Osmose", "subscriptions_url": "https://api.github.com/users/Osmose/subscriptions", "avatar_url": "https://avatars1.githubusercontent.com/u/193106?v=4", "repos_url": "https://api.github.com/users/Osmose/repos", "received_events_url": "https://api.github.com/users/Osmose/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/Osmose/starred{/owner}{/repo}", "site_admin": false, "login": "Osmose", "type": "User", "id": 193106, "followers_url": "https://api.github.com/users/Osmose/followers"}, "position": null, "path": "recipe-client-addon/lib/PreferenceExperiments.jsm", "body_html": "<p>With this <code>PREF_INVALID</code> and <code>hasOwnProperty</code> check, if a user gives an invalid preference type, one of two things may happen:</p>\n<ol>\n<li>If the preference has an existing value, the type check will fail and claim that it was expecting an invalid-typed preference. This is difficult to debug, because that error doesn't clearly indicate that the problem is a malformed preference type coming from the arguments.</li>\n<li>If the preference doesn't have an existing value, the type check will pass. Since nothing fails, we can't detect this, despite the preference type being incorrect.</li>\n</ol>\n<p>To make it easier for developers to catch problems with malformed preference types (which we type-check on the server using JSON schema anyway), we should check if the preference type is in the list near the start of the function and throw an error if it isn't. Then you can just check succinctly:</p>\n<div class=\"highlight highlight-source-js\"><pre><span class=\"pl-k\">const</span> <span class=\"pl-c1\">existingPreferenceType</span> <span class=\"pl-k\">=</span> <span class=\"pl-smi\">Services</span>.<span class=\"pl-smi\">prefs</span>.<span class=\"pl-en\">getPrefType</span>(preferenceName);\n<span class=\"pl-k\">if</span> (existingPreferenceType <span class=\"pl-k\">!==</span> <span class=\"pl-c1\">PREFERENCE_TYPE_MAP</span>[preferenceType]) {\n\n}</pre></div>", "original_commit_id": "d74e71bc7c86d392e193d79a3cc819bb7d2427c6", "id": 112110972}