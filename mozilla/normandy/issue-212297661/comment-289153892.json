{"body": "> I propose that we use this opportunity to decouple our execution from the browser start. Instead I suggest that we keep a record of the last time we have run. If it has been more than 24 hours since the last run, run again. We would check at browser start up, and then again periodically.\r\n\r\nWhat are the benefits of making this change?\r\n\r\n> This technique assumes that the client's clock is at least monotonic and increasing at about 1 second per second. We don't have any way to check the time more than that in a way that I'm happy with, for now. We'll use UTC to deal with time zones. The timestamps we use to test filter expressions come from the server, but that particular query happens to be one of the most expensive ones we have, so we definitely can't increase its load by 50x overnight.\r\n\r\nI've been told by several different people over the years that client clocks are broken in very odd ways for many users. Does the app updater, for example, rely on the client clock, or does it get around this issue somehow?\r\n\r\nIf we can't get confirmation that other high-priority update mechanisms consider the client clock reliable, I don't think it's wise for us to make this assumption. \r\n\r\n>> Every startup (NECESARY TO handles experiment tagging for ongoing At least once per day for ongoing sessions.\r\n>\r\n> I can't parse this paragraph. Did something go wrong with a copy/paste?\r\n\r\nI believe Gregg is pointing out that he thinks we need to execute recipes on startup to make sure we tag in-progress experiments in Telemetry, as the Telemetry API for marking a user as active in an experiment doesn't retain state between sessions and needs to be called on startup. \r\n\r\nBut, I think we're okay here, because the add-on will be keeping tracking of this without needing to run recipes. On startup, the add-on will, independently of running recipes, inform Telemetry of active experiments, and then the next time we execute recipes, will inform Telemetry if any of the experiments were deactivated.", "body_text": "I propose that we use this opportunity to decouple our execution from the browser start. Instead I suggest that we keep a record of the last time we have run. If it has been more than 24 hours since the last run, run again. We would check at browser start up, and then again periodically.\n\nWhat are the benefits of making this change?\n\nThis technique assumes that the client's clock is at least monotonic and increasing at about 1 second per second. We don't have any way to check the time more than that in a way that I'm happy with, for now. We'll use UTC to deal with time zones. The timestamps we use to test filter expressions come from the server, but that particular query happens to be one of the most expensive ones we have, so we definitely can't increase its load by 50x overnight.\n\nI've been told by several different people over the years that client clocks are broken in very odd ways for many users. Does the app updater, for example, rely on the client clock, or does it get around this issue somehow?\nIf we can't get confirmation that other high-priority update mechanisms consider the client clock reliable, I don't think it's wise for us to make this assumption.\n\n\nEvery startup (NECESARY TO handles experiment tagging for ongoing At least once per day for ongoing sessions.\n\nI can't parse this paragraph. Did something go wrong with a copy/paste?\n\nI believe Gregg is pointing out that he thinks we need to execute recipes on startup to make sure we tag in-progress experiments in Telemetry, as the Telemetry API for marking a user as active in an experiment doesn't retain state between sessions and needs to be called on startup.\nBut, I think we're okay here, because the add-on will be keeping tracking of this without needing to run recipes. On startup, the add-on will, independently of running recipes, inform Telemetry of active experiments, and then the next time we execute recipes, will inform Telemetry if any of the experiments were deactivated.", "url": "https://api.github.com/repos/mozilla/normandy/issues/comments/289153892", "created_at": "2017-03-24T22:03:20Z", "author_association": "MEMBER", "html_url": "https://github.com/mozilla/normandy/issues/588#issuecomment-289153892", "updated_at": "2017-03-24T22:03:20Z", "user": {"following_url": "https://api.github.com/users/Osmose/following{/other_user}", "events_url": "https://api.github.com/users/Osmose/events{/privacy}", "organizations_url": "https://api.github.com/users/Osmose/orgs", "url": "https://api.github.com/users/Osmose", "gists_url": "https://api.github.com/users/Osmose/gists{/gist_id}", "html_url": "https://github.com/Osmose", "subscriptions_url": "https://api.github.com/users/Osmose/subscriptions", "avatar_url": "https://avatars1.githubusercontent.com/u/193106?v=4", "repos_url": "https://api.github.com/users/Osmose/repos", "received_events_url": "https://api.github.com/users/Osmose/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/Osmose/starred{/owner}{/repo}", "site_admin": false, "login": "Osmose", "type": "User", "id": 193106, "followers_url": "https://api.github.com/users/Osmose/followers"}, "body_html": "<blockquote>\n<p>I propose that we use this opportunity to decouple our execution from the browser start. Instead I suggest that we keep a record of the last time we have run. If it has been more than 24 hours since the last run, run again. We would check at browser start up, and then again periodically.</p>\n</blockquote>\n<p>What are the benefits of making this change?</p>\n<blockquote>\n<p>This technique assumes that the client's clock is at least monotonic and increasing at about 1 second per second. We don't have any way to check the time more than that in a way that I'm happy with, for now. We'll use UTC to deal with time zones. The timestamps we use to test filter expressions come from the server, but that particular query happens to be one of the most expensive ones we have, so we definitely can't increase its load by 50x overnight.</p>\n</blockquote>\n<p>I've been told by several different people over the years that client clocks are broken in very odd ways for many users. Does the app updater, for example, rely on the client clock, or does it get around this issue somehow?</p>\n<p>If we can't get confirmation that other high-priority update mechanisms consider the client clock reliable, I don't think it's wise for us to make this assumption.</p>\n<blockquote>\n<blockquote>\n<p>Every startup (NECESARY TO handles experiment tagging for ongoing At least once per day for ongoing sessions.</p>\n</blockquote>\n<p>I can't parse this paragraph. Did something go wrong with a copy/paste?</p>\n</blockquote>\n<p>I believe Gregg is pointing out that he thinks we need to execute recipes on startup to make sure we tag in-progress experiments in Telemetry, as the Telemetry API for marking a user as active in an experiment doesn't retain state between sessions and needs to be called on startup.</p>\n<p>But, I think we're okay here, because the add-on will be keeping tracking of this without needing to run recipes. On startup, the add-on will, independently of running recipes, inform Telemetry of active experiments, and then the next time we execute recipes, will inform Telemetry if any of the experiments were deactivated.</p>", "id": 289153892, "issue_url": "https://api.github.com/repos/mozilla/normandy/issues/588"}