{"original_position": 132, "diff_hunk": "@@ -77,64 +80,84 @@ class Recipe(models.Model):\n     sample_rate = PercentField(default=100)\n     release_channels = models.ManyToManyField(ReleaseChannel, blank=True)\n \n-    def log_rejection(self, msg):\n-        logger.debug('{} rejected: {}'.format(self, msg))\n+    _registered_matchers = []\n \n-    def check_many(self, name, field_qs, client_val):\n-        field_vals = list(field_qs.all())\n-\n-        if field_vals == []:\n-            return True\n-\n-        for val in field_vals:\n-            if val.matches(client_val):\n-                return True\n-\n-        field_vals_str = ', '.join(str(o) for o in field_vals)\n-        self.log_rejection('client {name} ({client_val}) does not match recipe '\n-                           '(choices are {field_vals})'\n-                           .format(name=name, client_val=client_val, field_vals=field_vals_str))\n-        return False\n+    @classmethod\n+    def register_matcher(cls, func):\n+        cls._registered_matchers.append(func)\n \n     def matches(self, client):\n         \"\"\"\n         Return whether this Recipe should be sent to the given client.\n         \"\"\"\n-        # This should be ordered roughly by performance cost\n-        if not self.enabled:\n-            self.log_rejection('not enabled')\n-            return False\n+        for matcher in self._registered_matchers:\n+            if not matcher(self, client):\n+                return False\n \n-        if self.start_time and self.start_time > client.request_time:\n-            self.log_rejection('start time not met ({})'.format(self.start_time))\n-            return False\n+        return True\n \n-        if self.end_time and self.end_time < client.request_time:\n-            self.log_rejection('end time already passed ({})'.format(self.end_time))\n-            return False\n+    def __repr__(self):\n+        return '<Recipe \"{name}\">'.format(name=self.name)\n \n-        if self.sample_rate:\n-            inputs = [self.pk, client.user_id]\n-            if not utils.deterministic_sample(self.sample_rate / 100.0, inputs):\n-                self.log_rejection('did not match sample')\n-                return False\n+    def __str__(self):\n+        return self.name\n \n-        if not self.check_many('locale', self.locales, client.locale):\n-            return False\n \n-        if not self.check_many('country', self.countries, client.country):\n-            return False\n+@Recipe.register_matcher\n+def match_enabled(recipe, client):\n+    return recipe.enabled\n+\n \n-        if not self.check_many('channel', self.release_channels, client.release_channel):\n+@Recipe.register_matcher\n+def match_times(recipe, client):\n+    if recipe.start_time and recipe.start_time > client.request_time:\n+        return False\n+\n+    if recipe.end_time and recipe.end_time < client.request_time:\n+        return False\n+\n+    return True\n+\n+\n+@Recipe.register_matcher\n+def match_sample_rate(recipe, client):\n+    if recipe.sample_rate:\n+        inputs = [recipe.pk, client.user_id]\n+        if not utils.deterministic_sample(recipe.sample_rate / 100.0, inputs):\n             return False\n \n-        return True\n+    return True\n \n-    def __repr__(self):\n-        return '<Recipe \"{name}\">'.format(name=self.name)\n \n-    def __str__(self):\n-        return self.name\n+def multivalue_matcher(field_getter):\n+    \"\"\"Make a matcher that accepts the client if any of the recipe's values accept the client.\"\"\"", "body_text": "I think this docstring should document that we expect a matches function on the values we're comparing and what arguments it should take.", "pull_request_url": "https://api.github.com/repos/mozilla/normandy/pulls/44", "url": "https://api.github.com/repos/mozilla/normandy/pulls/comments/54182848", "created_at": "2016-02-25T23:24:03Z", "author_association": "MEMBER", "body": "I think this docstring should document that we expect a `matches` function on the values we're comparing and what arguments it should take.\n", "updated_at": "2016-02-26T18:33:57Z", "html_url": "https://github.com/mozilla/normandy/pull/44#discussion_r54182848", "pull_request_review_id": null, "_links": {"self": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/comments/54182848"}, "html": {"href": "https://github.com/mozilla/normandy/pull/44#discussion_r54182848"}, "pull_request": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/44"}}, "commit_id": "0efd449364de014dacffd27703cebb9fe36e8dfc", "user": {"following_url": "https://api.github.com/users/Osmose/following{/other_user}", "events_url": "https://api.github.com/users/Osmose/events{/privacy}", "organizations_url": "https://api.github.com/users/Osmose/orgs", "url": "https://api.github.com/users/Osmose", "gists_url": "https://api.github.com/users/Osmose/gists{/gist_id}", "html_url": "https://github.com/Osmose", "subscriptions_url": "https://api.github.com/users/Osmose/subscriptions", "avatar_url": "https://avatars1.githubusercontent.com/u/193106?v=4", "repos_url": "https://api.github.com/users/Osmose/repos", "received_events_url": "https://api.github.com/users/Osmose/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/Osmose/starred{/owner}{/repo}", "site_admin": false, "login": "Osmose", "type": "User", "id": 193106, "followers_url": "https://api.github.com/users/Osmose/followers"}, "position": null, "path": "normandy/recipes/models.py", "body_html": "<p>I think this docstring should document that we expect a <code>matches</code> function on the values we're comparing and what arguments it should take.</p>", "original_commit_id": "596da762920efe601619b6b89101219816d04326", "id": 54182848}