{"original_position": 242, "diff_hunk": "@@ -59,130 +54,163 @@ def update_signatures(self):\n             recipe.save()\n \n \n-@reversion.register()\n class Recipe(DirtyFieldsMixin, models.Model):\n     \"\"\"A set of actions to be fetched and executed by users.\"\"\"\n     objects = RecipeQuerySet.as_manager()\n \n-    name = models.CharField(max_length=255, unique=True)\n-    revision_id = models.IntegerField(default=0, editable=False)\n-    last_updated = models.DateTimeField(default=timezone.now)\n-\n-    action = models.ForeignKey('Action')\n-    arguments_json = models.TextField(default='{}', validators=[validate_json])\n+    latest_revision = models.ForeignKey('RecipeRevision', null=True, on_delete=models.SET_NULL,\n+                                        related_name='latest_for_recipe')\n \n     # Fields that determine who this recipe is sent to.\n     enabled = models.BooleanField(default=False)\n-    filter_expression = models.TextField(blank=False)\n-    approval = models.OneToOneField(Approval, related_name='recipe', null=True, blank=True)\n-\n-    signature = models.OneToOneField(Signature, related_name='recipe', null=True, blank=True)\n+    signature = models.OneToOneField(Signature, related_name='recipe_revision', null=True,\n+                                     blank=True)\n \n     class Meta:\n-        ordering = ['-enabled', '-last_updated']\n+        ordering = ['-enabled', '-latest_revision__updated']\n \n-    class IsNotApproved(Exception):\n-        pass\n+    def __repr__(self):\n+        return '<Recipe \"{name}\">'.format(name=self.name)\n+\n+    def __str__(self):\n+        return self.name\n \n     @property\n-    def is_approved(self):\n-        return self.approval is not None\n+    def name(self):\n+        return self.latest_revision.name if self.latest_revision else None\n \n     @property\n-    def arguments(self):\n-        return json.loads(self.arguments_json)\n+    def action(self):\n+        return self.latest_revision.action if self.latest_revision else None\n \n-    @arguments.setter\n-    def arguments(self, value):\n-        self.arguments_json = json.dumps(value)\n+    @property\n+    def filter_expression(self):\n+        return self.latest_revision.filter_expression if self.latest_revision else None\n \n     @property\n-    def current_approval_request(self):\n-        try:\n-            return self.approval_requests.get(active=True)\n-        except ApprovalRequest.DoesNotExist:\n-            return None\n+    def arguments_json(self):\n+        return self.latest_revision.arguments_json if self.latest_revision else None\n \n-    def enable(self):\n-        self.enabled = True\n+    @property\n+    def arguments(self):\n+        return self.latest_revision.arguments if self.latest_revision else None\n \n-    def disable(self):\n-        self.enabled = False\n-        self.approval = None\n+    @property\n+    def revision_id(self):\n+        return self.latest_revision.id if self.latest_revision else None\n \n-    _registered_matchers = []\n+    @property\n+    def last_updated(self):\n+        return self.latest_revision.updated if self.latest_revision else None\n \n-    def __repr__(self):\n-        return '<Recipe \"{name}\">'.format(name=self.name)\n+    def canonical_json(self):\n+        from normandy.recipes.api.serializers import RecipeSerializer  # Avoid circular import\n+        data = RecipeSerializer(self).data\n+        return CanonicalJSONRenderer().render(data)\n \n-    def __str__(self):\n-        return self.name\n+    def update_signature(self):\n+        autographer = Autographer()\n+\n+        logger.info(\n+            'Requesting signatures for recipes with ids [%s] from Autograph',\n+            self.id,\n+            extra={'recipe_ids': [self.id]})\n+\n+        signature_data = autographer.sign_data([self.canonical_json()])[0]\n+        signature = Signature(**signature_data)\n+        signature.save()\n+        self.signature = signature\n \n     @transaction.atomic\n-    def save(self, *args, skip_last_updated=False, **kwargs):\n-        if self.is_dirty(check_relationship=True):\n-            dirty_fields = self.get_dirty_fields(check_relationship=True)\n+    def update(self, force=False, **data):\n+        if self.latest_revision:\n+            is_clean = RecipeRevision.objects.filter(id=self.latest_revision.id, **data).exists()\n \n-            # If only the signature changed, skip the rest of the updates here,\n-            # to avoid invalidating that signature. If the signature changed\n-            # along with something else, raise an error, since the signature\n-            # will probably be invalid. Otherwise, try and generate a new\n-            # signature for the object. If that fails, remove the signature,\n-            # because it is invalid now.\n+            revision_data = self.latest_revision.data\n+            revision_data.update(data)\n+            data = revision_data\n+        else:\n+            is_clean = False\n \n+        if not is_clean or force:\n+            self.latest_revision = RecipeRevision.objects.create(\n+                recipe=self, parent=self.latest_revision, **data)\n+            self.save()\n+\n+    def save(self, *args, **kwargs):\n+        if self.is_dirty(check_relationship=True):\n+            dirty_fields = self.get_dirty_fields(check_relationship=True)\n             dirty_field_names = list(dirty_fields.keys())\n-            should_sign = False\n \n-            if dirty_field_names == ['signature']:\n-                super().save(*args, **kwargs)\n-                return\n-            elif 'signature' in dirty_field_names and self.signature is not None:\n+            if (len(dirty_field_names) > 1 and 'signature' in dirty_field_names\n+                    and self.signature is not None):\n                 # Setting the signature while also changing something else is probably\n                 # going to make the signature immediately invalid. Don't allow it.\n                 raise ValidationError('Signatures must change alone')\n-            else:\n-                should_sign = True\n-\n-            # Increment the revision ID, unless someone else tried to change it.\n-            if 'revision_id' not in dirty_field_names:\n-                self.revision_id += 1\n-\n-            if reversion.is_active():\n-                reversion.add_to_revision(self)\n \n-            if not skip_last_updated:\n-                self.last_updated = timezone.now()\n+            if dirty_field_names != ['signature']:\n+                super().save(*args, **kwargs)\n+                kwargs['force_insert'] = False\n \n-            if should_sign:\n                 try:\n-                    if self.id is None:\n-                        # Save now, to get an ID for the signature.\n-                        super().save(*args, **kwargs)\n-                        # Change from insert to update, so the save() call at the end doesn't fail\n-                        kwargs['force_insert'] = False\n                     self.update_signature()\n                 except ImproperlyConfigured:\n                     self.signature = None\n \n         super().save(*args, **kwargs)\n \n-    def canonical_json(self):\n-        from normandy.recipes.api.serializers import RecipeSerializer  # Avoid circular import\n-        data = RecipeSerializer(self).data\n-        return CanonicalJSONRenderer().render(data)\n \n-    def update_signature(self):\n-        autographer = Autographer()\n+class RecipeRevision(models.Model):\n+    id = models.CharField(max_length=64, primary_key=True)\n+    parent = models.OneToOneField('self', null=True, on_delete=models.CASCADE,\n+                                  related_name='child')\n+    recipe = models.ForeignKey(Recipe, related_name='revisions')\n+    created = models.DateTimeField(default=timezone.now)\n+    updated = models.DateTimeField(default=timezone.now)\n+    user = models.ForeignKey(User, on_delete=models.SET_NULL, related_name='recipe_revisions',\n+                             null=True)\n+    comment = models.TextField()\n \n-        logger.info(\n-            'Requesting signatures for recipes with ids [%s] from Autograph',\n-            self.id,\n-            extra={'recipe_ids': [self.id]})\n+    name = models.CharField(max_length=255)\n+    action = models.ForeignKey('Action', related_name='recipe_revisions')\n+    arguments_json = models.TextField(default='{}', validators=[validate_json])\n+    filter_expression = models.TextField(blank=False)\n \n-        signature_data = autographer.sign_data([self.canonical_json()])[0]\n-        signature = Signature(**signature_data)\n-        signature.save()\n-        self.signature = signature\n+    @property\n+    def data(self):\n+        return {\n+            'name': self.name,\n+            'action': self.action,\n+            'arguments_json': self.arguments_json,\n+            'filter_expression': self.filter_expression,\n+        }\n+\n+    @property\n+    def arguments(self):\n+        return json.loads(self.arguments_json)\n+\n+    @arguments.setter\n+    def arguments(self, value):\n+        self.arguments_json = json.dumps(value)\n+\n+    @property\n+    def restored_recipe(self):\n+        recipe = self.recipe\n+        recipe.latest_revision = self\n+        return recipe\n+\n+    def save(self, *args, skip_updated=False, **kwargs):", "body_text": "Is skip_updated ever used? I don't see it anywhere.", "pull_request_url": "https://api.github.com/repos/mozilla/normandy/pulls/410", "url": "https://api.github.com/repos/mozilla/normandy/pulls/comments/95223165", "created_at": "2017-01-09T19:04:56Z", "author_association": "MEMBER", "body": "Is `skip_updated` ever used? I don't see it anywhere.", "updated_at": "2017-01-13T22:13:08Z", "html_url": "https://github.com/mozilla/normandy/pull/410#discussion_r95223165", "pull_request_review_id": 15764714, "_links": {"self": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/comments/95223165"}, "html": {"href": "https://github.com/mozilla/normandy/pull/410#discussion_r95223165"}, "pull_request": {"href": "https://api.github.com/repos/mozilla/normandy/pulls/410"}}, "commit_id": "c80dbf01212e9ece69fb8c06c7def0ffc84bb898", "user": {"following_url": "https://api.github.com/users/mythmon/following{/other_user}", "events_url": "https://api.github.com/users/mythmon/events{/privacy}", "organizations_url": "https://api.github.com/users/mythmon/orgs", "url": "https://api.github.com/users/mythmon", "gists_url": "https://api.github.com/users/mythmon/gists{/gist_id}", "html_url": "https://github.com/mythmon", "subscriptions_url": "https://api.github.com/users/mythmon/subscriptions", "avatar_url": "https://avatars3.githubusercontent.com/u/305049?v=4", "repos_url": "https://api.github.com/users/mythmon/repos", "received_events_url": "https://api.github.com/users/mythmon/received_events", "gravatar_id": "", "starred_url": "https://api.github.com/users/mythmon/starred{/owner}{/repo}", "site_admin": false, "login": "mythmon", "type": "User", "id": 305049, "followers_url": "https://api.github.com/users/mythmon/followers"}, "position": null, "path": "normandy/recipes/models.py", "body_html": "<p>Is <code>skip_updated</code> ever used? I don't see it anywhere.</p>", "original_commit_id": "09b5dcf15d4168ab62565098469b018c80f4dfa8", "id": 95223165}